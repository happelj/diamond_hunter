<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Diamond Hunter</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Arial', sans-serif;
    }

    /* Game UI Elements */
    #gameUI {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }

    #overlay {
      position: absolute;
      top: 20px;
      left: 20px;
      color: #fff;
      font-size: 24px;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 10px 20px;
      border-radius: 10px;
      z-index: 100;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
    }

    #startScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    #startScreen h1 {
      color: #fff;
      font-size: 48px;
      margin-bottom: 20px;
      text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
    }

    #difficultySelector {
      background-color: rgba(0, 0, 0, 0.7);
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 30px;
      pointer-events: auto;
    }

    #difficultySelector h2 {
      color: #fff;
      font-size: 24px;
      margin-top: 0;
      margin-bottom: 15px;
      text-align: center;
    }

    .difficultyOptions {
      display: flex;
      justify-content: center;
      gap: 15px;
    }

    .difficultyBtn {
      background-color: #333;
      color: #fff;
      font-size: 18px;
      padding: 10px 20px;
      border: 2px solid #555;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s;
    }

    .difficultyBtn.selected {
      background-color: #00ffff;
      color: #000;
      border-color: #00ffff;
      transform: scale(1.05);
    }

    .difficultyBtn:hover:not(.selected) {
      background-color: #444;
      border-color: #00ffff;
    }

    #startButton {
      background-color: #00ffff;
      color: #000;
      font-size: 24px;
      padding: 15px 30px;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
      pointer-events: auto;
    }

    #startButton:hover {
      background-color: #ffffff;
      transform: scale(1.1);
    }

    #gameOverScreen,
    #winScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 900;
    }

    #gameOverScreen h1 {
      color: #ff0000;
      font-size: 60px;
      margin-bottom: 20px;
      text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000;
    }

    #winScreen h1 {
      color: #00ffff;
      font-size: 60px;
      margin-bottom: 20px;
      text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
    }

    .restartButton {
      background-color: #ffffff;
      color: #000;
      font-size: 24px;
      padding: 15px 30px;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
      pointer-events: auto;
      margin-top: 20px;
    }

    .restartButton:hover {
      background-color: #00ffff;
      transform: scale(1.1);
    }

    /* Controls guide */
    #controlsGuide {
      position: absolute;
      bottom: 20px;
      left: 20px;
      color: #fff;
      font-size: 18px;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 10px;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
    }

    /* Game tips */
    #gameTip {
      position: absolute;
      bottom: 20px;
      right: 20px;
      color: #fff;
      font-size: 18px;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 10px;
      max-width: 300px;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
      display: none;
    }

    /* Timer element */
    #timer {
      position: absolute;
      top: 20px;
      right: 20px;
      color: #fff;
      font-size: 24px;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 10px 20px;
      border-radius: 10px;
      z-index: 100;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
    }

    /* Difficulty indicator */
    #difficultyIndicator {
      position: absolute;
      top: 70px;
      right: 20px;
      color: #fff;
      font-size: 18px;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 8px 15px;
      border-radius: 10px;
      z-index: 100;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
      display: none;
    }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.module.js",
      "three/": "https://cdn.jsdelivr.net/npm/three@0.152.0/"
    }
  }
  </script>
</head>

<body>
  <div id="gameUI">
    <div id="overlay" style="display:none;">Diamonds: <span id="score">0</span>/<span id="totalDiamonds">100</span>
    </div>
    <div id="timer" style="display:none;">Time: <span id="timeElapsed">0</span>s</div>
    <div id="difficultyIndicator" style="display:none;">Difficulty: <span id="currentDifficulty">Normal</span></div>
    <div id="controlsGuide" style="display:none;">
      <strong>Controls:</strong> W,A,S,D to move | Mouse to look | Space to jump | F for fireworks | ESC to pause
    </div>
    <div id="gameTip" style="display:none;">
      <strong>TIP:</strong> Hide in bushes or climb trees to escape monsters. Yellow monsters only chase when you're
      close!
    </div>

    <div id="startScreen">
      <h1>DIAMOND HUNTER</h1>
      <div id="difficultySelector">
        <h2>SELECT DIFFICULTY</h2>
        <div class="difficultyOptions">
          <button class="difficultyBtn" data-difficulty="easy">Easy</button>
          <button class="difficultyBtn selected" data-difficulty="normal">Normal</button>
          <button class="difficultyBtn" data-difficulty="hard">Hard</button>
        </div>
      </div>
      <button id="startButton">START GAME</button>
    </div>

    <div id="gameOverScreen">
      <h1>GAME OVER</h1>
      <p style="color: #fff; font-size: 24px;">You collected <span id="finalScore">0</span> diamonds</p>
      <p style="color: #fff; font-size: 18px;">Difficulty: <span id="gameOverDifficulty">Normal</span></p>
      <button class="restartButton" id="restartButtonGameOver">TRY AGAIN</button>
    </div>

    <div id="winScreen">
      <h1>YOU WIN!</h1>
      <p style="color: #fff; font-size: 24px;">You collected all <span id="winTotalDiamonds">100</span> diamonds in
        <span id="finalTime">0</span> seconds
      </p>
      <p style="color: #fff; font-size: 18px;">Difficulty: <span id="winDifficulty">Normal</span></p>
      <button class="restartButton" id="restartButtonWin">PLAY AGAIN</button>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls.js';

    let camera, scene, renderer, controls;
    const diamonds = [];
    const monsters = [];
    const yellowMonsters = [];
    const monsterInitialPositions = [];
    const yellowMonsterInitialPositions = [];
    let totalDiamonds = 0;
    let score = 0;
    let won = false;
    let lost = false;
    let gameActive = false;
    let gamePaused = false;
    let gameTime = 0;
    let gameTimer;

    // Difficulty settings
    const difficulties = {
      easy: { monsterSpeed: 0.25, yellowMonsterSpeed: 0.4, name: "Easy" },
      normal: { monsterSpeed: 0.5, yellowMonsterSpeed: 0.8, name: "Normal" },
      hard: { monsterSpeed: 0.8, yellowMonsterSpeed: 1.2, name: "Hard" }
    };
    let currentDifficulty = "normal";

    // Player physics for jumping
    const player = {
      height: 10,           // Player's height off the ground
      jumping: false,       // Is player currently jumping?
      jumpHeight: 60,       // Maximum jump height
      jumpSpeed: 2,         // Jump velocity
      gravity: 0.07,        // Gravity force pulling down
      velocity: 0,          // Current vertical velocity
      jumpCooldown: 0,      // Cooldown timer for jumps
      insideBush: false,    // Whether player is inside a bush
      onTree: false,        // Whether player is standing on a tree
      groundLevel: 10       // Current ground level (10 for ground, higher for trees)
    };

    // Bush data storage
    const bushes = [];

    // Tree data storage for custom collision and climbing
    const trees = [];

    // Fireworks particle class
    class FireworkParticle {
      constructor(position) {
        const geom = new THREE.SphereGeometry(2, 8, 8);
        const color = new THREE.Color().setHSL(Math.random(), 1.0, 0.5);
        this.mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 });
        this.mesh = new THREE.Mesh(geom, this.mat);
        this.mesh.position.copy(position);
        const dir = new THREE.Vector3((Math.random() * 2 - 1), (Math.random() * 2 - 1), (Math.random() * 2 - 1)).normalize();
        this.vel = dir.multiplyScalar(Math.random() * 4 + 2);
        this.age = 0;
        this.life = Math.random() * 40 + 60;
      }
      update() {
        this.mesh.position.add(this.vel);
        this.vel.y -= 0.1;
        this.age++;
        this.mat.opacity = 1 - this.age / this.life;
        return this.age < this.life;
      }
    }
    const fireworks = [];
    let fireworksRunning = false;
    let frameCount = 0;

    // Collision boxes & settings
    const collidableBoxes = []; // For non-tree obstacles like fences
    const boundary = { min: -900, max: 900 }; // Reduced for mountain barrier
    const playerCollider = { radius: 4 };
    const monsterCollider = { radius: 5 };

    // UI Elements
    let scoreEl;
    let totalDiamondsEl;
    let finalScoreEl;
    let winTotalDiamondsEl;
    let timeElapsedEl;
    let finalTimeEl;
    let overlayEl;
    let timerEl;
    let controlsGuideEl;
    let gameTipEl;
    let startScreenEl;
    let gameOverScreenEl;
    let winScreenEl;
    let difficultyIndicatorEl;
    let currentDifficultyEl;
    let gameOverDifficultyEl;
    let winDifficultyEl;
    let difficultyBtns;

    const keys = {};

    init();

    function init() {
      // Get UI elements
      scoreEl = document.getElementById('score');
      totalDiamondsEl = document.getElementById('totalDiamonds');
      finalScoreEl = document.getElementById('finalScore');
      winTotalDiamondsEl = document.getElementById('winTotalDiamonds');
      timeElapsedEl = document.getElementById('timeElapsed');
      finalTimeEl = document.getElementById('finalTime');
      overlayEl = document.getElementById('overlay');
      timerEl = document.getElementById('timer');
      controlsGuideEl = document.getElementById('controlsGuide');
      gameTipEl = document.getElementById('gameTip');
      startScreenEl = document.getElementById('startScreen');
      gameOverScreenEl = document.getElementById('gameOverScreen');
      winScreenEl = document.getElementById('winScreen');
      difficultyIndicatorEl = document.getElementById('difficultyIndicator');
      currentDifficultyEl = document.getElementById('currentDifficulty');
      gameOverDifficultyEl = document.getElementById('gameOverDifficulty');
      winDifficultyEl = document.getElementById('winDifficulty');
      difficultyBtns = document.querySelectorAll('.difficultyBtn');

      // Set up difficulty selection
      difficultyBtns.forEach(btn => {
        btn.addEventListener('click', () => {
          difficultyBtns.forEach(b => b.classList.remove('selected'));
          btn.classList.add('selected');
          currentDifficulty = btn.dataset.difficulty;
        });
      });

      // Set up buttons
      document.getElementById('startButton').addEventListener('click', () => {
        if (gamePaused) {
          resumeGame();
        } else {
          startGame();
        }
      });
      document.getElementById('restartButtonGameOver').addEventListener('click', startGame);
      document.getElementById('restartButtonWin').addEventListener('click', startGame);

      // Set up scene
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 2000);
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);
      scene.fog = new THREE.Fog(0x87ceeb, 0, 750);

      const hemi = new THREE.HemisphereLight(0xffffff, 0x444444);
      hemi.position.set(0, 200, 0);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff);
      dir.position.set(0, 200, 100);
      scene.add(dir);

      controls = new PointerLockControls(camera, document.body);
      controls.addEventListener('lock', onLock);
      controls.addEventListener('unlock', onUnlock);
      scene.add(controls.getObject());
      controls.getObject().position.set(0, 10, 0);

      // Floor
      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(2000, 2000, 100, 100).rotateX(-Math.PI / 2),
        new THREE.MeshPhongMaterial({ color: 0x228B22 })
      );
      scene.add(floor);

      // Trees with climbing capability
      spawnTrees(50);

      // Clouds
      for (let i = 0; i < 20; i++) {
        const cloud = new THREE.Group();
        for (let j = 0; j < 5; j++) {
          const c = new THREE.Mesh(
            new THREE.SphereGeometry(20, 8, 8),
            new THREE.MeshPhongMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 })
          );
          c.position.set(Math.random() * 40 - 20, Math.random() * 10, Math.random() * 40 - 20);
          cloud.add(c);
        }
        cloud.position.set(Math.random() * 1600 - 800, 200 + Math.random() * 100, Math.random() * 1600 - 800);
        scene.add(cloud);
      }

      // Diamonds
      spawnDiamonds(100);
      totalDiamonds = diamonds.length;
      totalDiamondsEl.textContent = totalDiamonds;
      winTotalDiamondsEl.textContent = totalDiamonds;

      // Red Monsters
      spawnMonsters(8);

      // Yellow Monsters
      spawnYellowMonsters(5);

      // Set up map boundaries - fence and bushes
      createMapBoundaries();

      // Renderer
      renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      window.addEventListener('resize', onResize);
      document.addEventListener('keydown', onKey);
      document.addEventListener('keyup', onKey);
      animate();
    }

    function startGame() {
      // Reset everything
      resetGame();

      // Create new set of diamonds
      spawnDiamonds(100);
      totalDiamonds = diamonds.length;
      totalDiamondsEl.textContent = totalDiamonds;
      winTotalDiamondsEl.textContent = totalDiamonds;

      // Hide UI screens and show game UI
      startScreenEl.style.display = 'none';
      gameOverScreenEl.style.display = 'none';
      winScreenEl.style.display = 'none';

      // Start the timer
      gameTime = 0;
      clearInterval(gameTimer);
      gameTimer = setInterval(() => {
        if (gameActive && !won && !lost && !gamePaused) {
          gameTime++;
          timeElapsedEl.textContent = gameTime;
        }
      }, 1000);

      // Set game flags
      gameActive = true;
      gamePaused = false;

      // Update difficulty display
      currentDifficultyEl.textContent = difficulties[currentDifficulty].name;
      gameOverDifficultyEl.textContent = difficulties[currentDifficulty].name;
      winDifficultyEl.textContent = difficulties[currentDifficulty].name;

      // Lock controls
      controls.lock();
    }

    function pauseGame() {
      if (gameActive && !won && !lost) {
        gamePaused = true;
        controls.unlock();

        // Show pause screen
        overlayEl.style.display = 'none';
        timerEl.style.display = 'none';
        difficultyIndicatorEl.style.display = 'none';
        controlsGuideEl.style.display = 'none';
        gameTipEl.style.display = 'none';
        startScreenEl.style.display = 'flex';
        document.getElementById('startButton').textContent = 'RESUME GAME';
      }
    }

    function resumeGame() {
      if (gamePaused) {
        gamePaused = false;
        startScreenEl.style.display = 'none';

        // This is the fix for the resume bug:
        // We need to explicitly show the UI elements again
        overlayEl.style.display = 'block';
        timerEl.style.display = 'block';
        difficultyIndicatorEl.style.display = 'block';
        controlsGuideEl.style.display = 'block';
        gameTipEl.style.display = 'block';

        controls.lock();
      }
    }

    function onLock() {
      overlayEl.style.display = 'block';
      timerEl.style.display = 'block';
      difficultyIndicatorEl.style.display = 'block';
      controlsGuideEl.style.display = 'block';
      gameTipEl.style.display = 'block';
    }

    function onUnlock() {
      if (gameActive && !won && !lost && !gamePaused) {
        pauseGame();
      }
    }

    function gameOver() {
      gameActive = false;
      lost = true;
      gamePaused = false;
      controls.unlock();

      // Show game over screen
      finalScoreEl.textContent = score;
      gameOverDifficultyEl.textContent = difficulties[currentDifficulty].name;
      gameOverScreenEl.style.display = 'flex';

      // Stop timer
      clearInterval(gameTimer);
    }

    function winGame() {
      gameActive = false;
      won = true;
      gamePaused = false;
      controls.unlock();

      // Show win screen
      finalTimeEl.textContent = gameTime;
      winDifficultyEl.textContent = difficulties[currentDifficulty].name;
      winScreenEl.style.display = 'flex';

      // Stop timer
      clearInterval(gameTimer);

      // Start victory fireworks
      fireworksRunning = true;

      // Schedule fireworks to stop after 10 seconds
      setTimeout(() => {
        fireworksRunning = false;
      }, 10000);
    }

    function addCollider(mesh) {
      // If it's a group, add colliders for each child that's a mesh
      if (mesh.isGroup) {
        mesh.traverse(child => {
          if (child.isMesh) {
            collidableBoxes.push(new THREE.Box3().setFromObject(child));
          }
        });
      } else {
        collidableBoxes.push(new THREE.Box3().setFromObject(mesh));
      }
    }

    // Function to spawn trees with climbing capability
    function spawnTrees(count) {
      trees.length = 0; // Clear trees array

      let placed = 0, attempts = 0;
      const maxAtt = count * 100;

      while (placed < count && attempts < maxAtt) {
        attempts++;
        const x = Math.random() * 1000 - 500;
        const z = Math.random() * 1000 - 500;

        // Test position to ensure trees don't overlap
        const testPosition = new THREE.Vector3(x, 0, z);
        let canPlace = true;

        // Check against existing trees
        for (const tree of trees) {
          const dx = tree.position.x - x;
          const dz = tree.position.z - z;
          const distSquared = dx * dx + dz * dz;

          if (distSquared < 400) { // 20 units minimum spacing between trees
            canPlace = false;
            break;
          }
        }

        if (canPlace) {
          // Create a tree group
          const treeGroup = new THREE.Group();
          treeGroup.position.set(x, 0, z);

          // Tree parameters with random height between 30-50
          const trunkHeight = 30 + Math.random() * 20; // Random height between 30-50
          const trunkRadius = 3.5; // Thicker trunk

          // Create trunk with thicker radius
          const trunk = new THREE.Mesh(
            new THREE.CylinderGeometry(trunkRadius, trunkRadius, trunkHeight, 10),
            new THREE.MeshPhongMaterial({ color: 0x8b4513 })
          );
          trunk.position.y = trunkHeight / 2;
          treeGroup.add(trunk);

          // Create foliage - size scaled with trunk height
          const foliageSize = 15 * (trunkHeight / 40); // Scale foliage with tree height

          // Position main foliage at the top of the trunk
          const mainFoliage = new THREE.Mesh(
            new THREE.SphereGeometry(foliageSize, 12, 12),
            new THREE.MeshPhongMaterial({ color: 0x006400 })
          );
          const foliageY = trunkHeight + foliageSize * 0.3;
          mainFoliage.position.y = foliageY;
          treeGroup.add(mainFoliage);

          // Add secondary foliage for more natural look
          const numFoliageClusters = 4 + Math.floor(trunkHeight / 10); // More clusters for taller trees
          for (let i = 0; i < numFoliageClusters; i++) {
            const angle = (Math.PI * 2 / numFoliageClusters) * i;
            const offsetX = Math.cos(angle) * foliageSize * 0.6;
            const offsetZ = Math.sin(angle) * foliageSize * 0.6;

            // Distribute foliage vertically in the upper third of the tree
            const heightFactor = 0.7 + (i % 3) * 0.1; // Different heights 
            const offsetY = trunkHeight * heightFactor + Math.random() * foliageSize * 0.3;

            const subFoliage = new THREE.Mesh(
              new THREE.SphereGeometry(foliageSize * (0.7 + Math.random() * 0.3), 10, 10),
              new THREE.MeshPhongMaterial({ color: 0x006400 })
            );
            subFoliage.position.set(offsetX, offsetY, offsetZ);
            treeGroup.add(subFoliage);
          }

          // For taller trees, add some mid-trunk foliage
          if (trunkHeight > 40) {
            const midHeight = trunkHeight * 0.6;
            for (let i = 0; i < 3; i++) {
              const angle = (Math.PI * 2 / 3) * i + Math.random() * 0.5;
              const offsetX = Math.cos(angle) * foliageSize * 0.7;
              const offsetZ = Math.sin(angle) * foliageSize * 0.7;

              const midFoliage = new THREE.Mesh(
                new THREE.SphereGeometry(foliageSize * 0.6, 10, 10),
                new THREE.MeshPhongMaterial({ color: 0x006400 })
              );
              midFoliage.position.set(offsetX, midHeight, offsetZ);
              treeGroup.add(midFoliage);
            }
          }

          // Store collision data including climbable area
          treeGroup.userData = {
            trunkRadius: trunkRadius + 2, // Add a bit of padding for collision
            height: trunkHeight,
            foliageHeight: foliageY,
            foliageRadius: foliageSize,
            climbableRadius: foliageSize + 3 // Slightly larger area for climbing
          };

          // Add to scene and trees array
          scene.add(treeGroup);
          trees.push(treeGroup);
          placed++;
        }
      }

      console.log(`Placed ${placed} climbable trees with random heights between 30-50 units`);
    }

    function spawnObjects(type, count, radius, place) {
      let placed = 0, attempts = 0;
      const maxAtt = count * 100;
      while (placed < count && attempts < maxAtt) {
        attempts++;
        const x = Math.random() * 1000 - 500;
        const z = Math.random() * 1000 - 500;
        const y = (type === 'mountain' ? 200 : 12);
        const pos = new THREE.Vector3(x, y, z);
        const test = new THREE.Sphere(pos, radius);
        if (!collidableBoxes.some(b => b.intersectsSphere(test))) { place(pos); placed++; }
      }
    }

    function spawnDiamonds(count) {
      // Clear any existing diamonds
      diamonds.forEach(d => {
        if (d) scene.remove(d);
      });
      diamonds.length = 0;

      const geo = new THREE.OctahedronGeometry(5);
      const mat = new THREE.MeshPhongMaterial({
        color: 0x00ffff,
        emissive: 0x007777,
        shininess: 100
      });

      let placed = 0;
      let attempts = 0;
      const maxAttempts = count * 100; // safety limit to prevent infinite loops

      while (placed < count && attempts < maxAttempts) {
        attempts++;
        const x = Math.random() * 1600 - 800;
        const z = Math.random() * 1600 - 800;
        const pos = new THREE.Vector3(x, 5, z);

        // Make sure the diamond doesn't spawn inside objects or outside boundary
        if (x < boundary.min || x > boundary.max || z < boundary.min || z > boundary.max) {
          continue; // Skip positions outside boundary
        }

        // Check for tree collisions
        let treeCollision = false;
        for (const tree of trees) {
          const dx = tree.position.x - pos.x;
          const dz = tree.position.z - pos.z;
          const distSquared = dx * dx + dz * dz;

          if (distSquared < tree.userData.trunkRadius * tree.userData.trunkRadius) {
            treeCollision = true;
            break;
          }
        }

        if (treeCollision) continue;

        // Test against other colliders
        const testSphere = new THREE.Sphere(pos, playerCollider.radius + 1);
        if (!collidableBoxes.some(b => b.intersectsSphere(testSphere))) {
          const d = new THREE.Mesh(geo, mat);
          d.position.copy(pos);
          d.userData = {
            rotationSpeed: Math.random() * 0.02 + 0.01,
            floatSpeed: Math.random() * 0.01 + 0.005,
            floatHeight: Math.random() * 0.5 + 0.5,
            startY: pos.y
          };
          scene.add(d);
          diamonds.push(d);
          placed++;
        }
      }

      // If we couldn't place all diamonds, log a warning
      if (placed < count) {
        console.warn(`Could only place ${placed} out of ${count} diamonds`);
      }

      return placed; // Return the number of diamonds actually placed
    }

    function spawnMonsters(count) {
      monsters.forEach(m => m && scene.remove(m));
      monsters.length = 0; monsterInitialPositions.length = 0;
      const bodyGeo = new THREE.BoxGeometry(10, 15, 10),
        bodyMat = new THREE.MeshPhongMaterial({ color: 0xff0000 }),
        eyeGeo = new THREE.SphereGeometry(1.5, 8, 8),
        eyeMat = new THREE.MeshPhongMaterial({ color: 0xffffff }),
        pupilGeo = new THREE.SphereGeometry(0.7, 8, 8),
        pupilMat = new THREE.MeshPhongMaterial({ color: 0x000000 });
      let placed = 0, attempts = 0;
      while (placed < count && attempts < count * 50) {
        attempts++;
        const x = Math.random() * 1000 - 500, z = Math.random() * 1000 - 500;
        const pos = new THREE.Vector3(x, 10, z);

        // Check for tree collisions
        let treeCollision = false;
        for (const tree of trees) {
          const dx = tree.position.x - pos.x;
          const dz = tree.position.z - pos.z;
          const distSquared = dx * dx + dz * dz;

          if (distSquared < tree.userData.trunkRadius * tree.userData.trunkRadius) {
            treeCollision = true;
            break;
          }
        }

        if (treeCollision) continue;

        // Check other colliders
        if (!collidableBoxes.some(b => b.intersectsSphere(new THREE.Sphere(pos, monsterCollider.radius + 1)))) {
          const mg = new THREE.Group();
          mg.userData = { type: 'red' };

          // Body
          const body = new THREE.Mesh(bodyGeo, bodyMat);
          mg.add(body);
          // Eyes (named)
          const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
          leftEye.name = 'eye';
          leftEye.position.set(-2.5, 5, 5);
          mg.add(leftEye);
          const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
          rightEye.name = 'eye';
          rightEye.position.set(2.5, 5, 5);
          mg.add(rightEye);
          // Pupils (named)
          const leftPupil = new THREE.Mesh(pupilGeo, pupilMat);
          leftPupil.name = 'pupil';
          leftPupil.position.set(-2.5, 5, 6);
          mg.add(leftPupil);
          const rightPupil = new THREE.Mesh(pupilGeo, pupilMat);
          rightPupil.name = 'pupil';
          rightPupil.position.set(2.5, 5, 6);
          mg.add(rightPupil);

          mg.position.copy(pos);
          scene.add(mg);
          monsters.push(mg);
          monsterInitialPositions.push(pos.clone());
          placed++;
        }
      }
    }

    function spawnYellowMonsters(count) {
      yellowMonsters.forEach(m => m && scene.remove(m));
      yellowMonsters.length = 0;
      yellowMonsterInitialPositions.length = 0;

      const bodyGeo = new THREE.BoxGeometry(10, 15, 10),
        bodyMat = new THREE.MeshPhongMaterial({ color: 0xffff00 }), // Yellow body
        eyeGeo = new THREE.SphereGeometry(1.5, 8, 8),
        eyeMat = new THREE.MeshPhongMaterial({ color: 0xffffff }),
        pupilGeo = new THREE.SphereGeometry(0.7, 8, 8),
        pupilMat = new THREE.MeshPhongMaterial({ color: 0x000000 });

      let placed = 0, attempts = 0;
      while (placed < count && attempts < count * 50) {
        attempts++;
        const x = Math.random() * 1000 - 500, z = Math.random() * 1000 - 500;
        const pos = new THREE.Vector3(x, 10, z);

        // Check for tree collisions
        let treeCollision = false;
        for (const tree of trees) {
          const dx = tree.position.x - pos.x;
          const dz = tree.position.z - pos.z;
          const distSquared = dx * dx + dz * dz;

          if (distSquared < tree.userData.trunkRadius * tree.userData.trunkRadius) {
            treeCollision = true;
            break;
          }
        }

        if (treeCollision) continue;

        // Check other colliders
        if (!collidableBoxes.some(b => b.intersectsSphere(new THREE.Sphere(pos, monsterCollider.radius + 1)))) {
          const mg = new THREE.Group();
          mg.userData = {
            type: 'yellow',
            activationRadius: 80, // Only move when player is within this range
            pursuitRadius: 120     // Stop pursuing when player gets this far
          };

          // Body
          const body = new THREE.Mesh(bodyGeo, bodyMat);
          mg.add(body);
          // Eyes (named)
          const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
          leftEye.name = 'eye';
          leftEye.position.set(-2.5, 5, 5);
          mg.add(leftEye);
          const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
          rightEye.name = 'eye';
          rightEye.position.set(2.5, 5, 5);
          mg.add(rightEye);
          // Pupils (named)
          const leftPupil = new THREE.Mesh(pupilGeo, pupilMat);
          leftPupil.name = 'pupil';
          leftPupil.position.set(-2.5, 5, 6);
          mg.add(leftPupil);
          const rightPupil = new THREE.Mesh(pupilGeo, pupilMat);
          rightPupil.name = 'pupil';
          rightPupil.position.set(2.5, 5, 6);
          mg.add(rightPupil);

          mg.position.copy(pos);
          scene.add(mg);
          yellowMonsters.push(mg);
          yellowMonsterInitialPositions.push(pos.clone());
          placed++;
        }
      }
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onKey(e) {
      if (e.code === 'KeyF' && e.type === 'keydown') fireworksRunning = !fireworksRunning;
      if (e.code === 'Escape' && e.type === 'keydown' && gameActive && !won && !lost) {
        if (gamePaused) {
          resumeGame();
        } else {
          pauseGame();
        }
      }

      // Track all key states
      keys[e.code] = e.type === 'keydown';

      // Prevent spacebar from scrolling the page
      if (e.code === 'Space') {
        e.preventDefault();
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      frameCount++;

      // Update diamond rotations and floating
      diamonds.forEach(d => {
        if (d) {
          d.rotation.y += d.userData.rotationSpeed;
          d.rotation.x += d.userData.rotationSpeed * 0.5;

          // Floating effect
          d.position.y = d.userData.startY +
            Math.sin(frameCount * d.userData.floatSpeed) * d.userData.floatHeight;
        }
      });

      const fireNow = fireworksRunning || (won && !lost);
      if (fireNow && frameCount % 30 === 0) {
        const burstPos = new THREE.Vector3(
          Math.random() * 800 - 400,
          Math.random() * 100 + 150,
          Math.random() * 800 - 400
        );
        for (let i = 0; i < 40; i++) {
          const p = new FireworkParticle(burstPos);
          scene.add(p.mesh);
          fireworks.push(p);
        }
      }

      // Update particles
      for (let i = fireworks.length - 1; i >= 0; i--) {
        if (!fireworks[i].update()) {
          scene.remove(fireworks[i].mesh);
          fireworks.splice(i, 1);
        }
      }

      if (gameActive && !won && !lost && !gamePaused && controls.isLocked) {
        updatePlayer();
        updateDiamonds();
        updateMonsters();
        updateYellowMonsters();
      }

      renderer.render(scene, camera);
    }

    function isPlayerInBush() {
      const playerPos = controls.getObject().position;

      for (const bush of bushes) {
        // Calculate distance from player to bush center (ignoring Y-axis)
        const bushCenter = bush.position.clone();
        const dx = playerPos.x - bushCenter.x;
        const dz = playerPos.z - bushCenter.z;
        const distSquared = dx * dx + dz * dz;

        // Check if player is inside this bush (using bush radius squared)
        if (distSquared < bush.userData.radius * bush.userData.radius) {
          return true;
        }
      }

      return false;
    }

    function isPlayerOnTree() {
      const playerPos = controls.getObject().position;

      for (const tree of trees) {
        // Calculate distance from player to tree center (ignoring Y-axis)
        const dx = playerPos.x - tree.position.x;
        const dz = playerPos.z - tree.position.z;
        const distSquared = dx * dx + dz * dz;

        // Check if player is within climbable radius and above foliage height
        if (distSquared < tree.userData.climbableRadius * tree.userData.climbableRadius &&
          playerPos.y >= tree.userData.foliageHeight - 5) {
          return { onTree: true, treeHeight: tree.userData.foliageHeight };
        }
      }

      return { onTree: false, treeHeight: 0 };
    }

    function checkTreeCollision(position, radius) {
      // Cylindrical collision check against all trees (only trunks, not foliage)
      for (const tree of trees) {
        // Calculate distance from position to tree center (ignoring Y-axis)
        const dx = position.x - tree.position.x;
        const dz = position.z - tree.position.z;
        const distSquared = dx * dx + dz * dz;

        // Only check trunk collision, not foliage (so players can climb)
        const collisionRadius = tree.userData.trunkRadius + radius;
        if (distSquared < collisionRadius * collisionRadius) {
          return true;
        }
      }

      return false;
    }

    function updatePlayer() {
      const pl = controls.getObject();

      // Check if player is inside any bush
      player.insideBush = isPlayerInBush();

      // Check if player is on a tree
      const treeCheck = isPlayerOnTree();
      player.onTree = treeCheck.onTree;

      // Update ground level based on tree position
      if (player.onTree) {
        player.groundLevel = treeCheck.treeHeight;
      } else {
        player.groundLevel = 10; // Normal ground level
      }

      // Handle jumping physics
      if (player.jumping) {
        // Apply velocity and gravity
        player.velocity -= player.gravity;
        pl.position.y += player.velocity;

        // Check if we've hit the ground (or tree foliage)
        if (pl.position.y <= player.groundLevel) {
          pl.position.y = player.groundLevel;
          player.jumping = false;
          player.velocity = 0;
          player.jumpCooldown = 10; // Set a short cooldown before next jump
        }
      } else {
        // Ensure player is at correct height when not jumping
        if (pl.position.y > player.groundLevel) {
          // Apply gravity when above ground/tree level
          pl.position.y -= 2;
          if (pl.position.y < player.groundLevel) {
            pl.position.y = player.groundLevel;
          }
        } else {
          pl.position.y = player.groundLevel;
        }

        // Handle jump initiation
        if (keys['Space'] && player.jumpCooldown <= 0) {
          player.jumping = true;
          player.velocity = player.jumpSpeed;

          // Play jump sound
          playJumpSound();
        }
      }

      // Update jump cooldown
      if (player.jumpCooldown > 0) {
        player.jumpCooldown--;
      }

      // Movement
      const old = pl.position.clone();
      const dlt = 0.1;
      const dir = new THREE.Vector3(
        (keys['KeyD'] ? 1 : 0) - (keys['KeyA'] ? 1 : 0),
        0,
        (keys['KeyS'] ? 1 : 0) - (keys['KeyW'] ? 1 : 0)
      ).normalize();

      if (dir.length()) {
        const v = dir.multiplyScalar(400 * dlt);
        pl.translateX(v.x * dlt);
        pl.translateZ(v.z * dlt);
        pl.position.x = Math.max(boundary.min, Math.min(boundary.max, pl.position.x));
        pl.position.z = Math.max(boundary.min, Math.min(boundary.max, pl.position.z));

        // Check for tree trunk collisions (not foliage - players can walk through foliage)
        if (checkTreeCollision(pl.position, playerCollider.radius)) {
          pl.position.copy(old);
        } else {
          // Check other colliders (fences, etc.)
          const sph = new THREE.Sphere(pl.position, playerCollider.radius);
          for (const b of collidableBoxes) {
            if (b.intersectsSphere(sph)) {
              pl.position.copy(old);
              break;
            }
          }
        }
      }
    }

    function updateDiamonds() {
      diamonds.forEach((d, i) => {
        if (d && d.position.distanceTo(controls.getObject().position) < 10) {
          scene.remove(d);
          diamonds[i] = null;
          score++;
          scoreEl.textContent = score;

          // Play pickup sound effect
          playPickupSound();

          if (score >= totalDiamonds) {
            winGame();
          }
        }
      });
    }

    function playPickupSound() {
      // Simple audio feedback using Web Audio API
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(880, audioContext.currentTime); // A5
        oscillator.frequency.exponentialRampToValueAtTime(
          1760, audioContext.currentTime + 0.1 // A6
        );

        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.2);
      } catch (e) {
        // Fallback if Web Audio API is not supported
        console.log("Audio feedback not supported");
      }
    }

    function playJumpSound() {
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.type = 'square';
        oscillator.frequency.setValueAtTime(220, audioContext.currentTime); // A3
        oscillator.frequency.exponentialRampToValueAtTime(
          440, audioContext.currentTime + 0.1 // A4
        );

        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.3);
      } catch (e) {
        // Fallback if Web Audio API is not supported
        console.log("Audio feedback not supported");
      }
    }

    function updateMonsters() {
      const playerPos = controls.getObject().position;

      // If player is inside a bush, red monsters stop moving
      if (player.insideBush) {
        return;
      }

      monsters.forEach(m => {
        // Rotate entire monster body on Y to face player
        const dir = new THREE.Vector3()
          .subVectors(playerPos, m.position)
          .setY(0)
          .normalize();
        if (dir.length()) {
          m.lookAt(m.position.clone().add(dir));
        }

        // Eye & pupil tracking
        m.traverse(obj => {
          if (obj.name === 'eye' || obj.name === 'pupil') {
            obj.lookAt(playerPos);
          }
        });

        // Step towards player with obstacle avoidance
        // Apply difficulty-based speed
        const speed = difficulties[currentDifficulty].monsterSpeed;
        const v = new THREE.Vector3().subVectors(playerPos, m.position).normalize().multiplyScalar(speed);

        const oldPos = m.position.clone();

        ['x', 'z'].forEach(ax => {
          const tp = m.position.clone();
          tp[ax] += v[ax];

          // Check for tree collisions
          if (!checkTreeCollision(tp, monsterCollider.radius)) {
            // Check other colliders
            const monsterSphere = new THREE.Sphere(tp, monsterCollider.radius);
            if (!collidableBoxes.some(b => b.intersectsSphere(monsterSphere))) {
              m.position[ax] += v[ax];
            }
          }
        });

        // Clamp
        m.position.x = Math.max(boundary.min, Math.min(boundary.max, m.position.x));
        m.position.z = Math.max(boundary.min, Math.min(boundary.max, m.position.z));
      });

      // Separate overlaps
      const sep = 20;
      monsters.forEach((a, i) => {
        monsters.forEach((b, j) => {
          if (i >= j) return;
          const d = a.position.distanceTo(b.position);
          if (d < sep) {
            const push = a.position.clone().sub(b.position).normalize().multiplyScalar((sep - d) / 2);
            a.position.add(push);
            b.position.sub(push);
          }
        });
      });

      // Check for catching player (only if not on tree)
      monsters.forEach(m => {
        if (m.position.distanceTo(controls.getObject().position) < 10 && !won && !lost && !player.onTree) {
          gameOver();
        }
      });
    }

    function updateYellowMonsters() {
      const playerPos = controls.getObject().position;

      // If player is inside a bush or on a tree, yellow monsters stop moving
      if (player.insideBush || player.onTree) {
        return;
      }

      yellowMonsters.forEach(m => {
        const distanceToPlayer = m.position.distanceTo(playerPos);

        // Only activate if player is close enough
        if (distanceToPlayer > m.userData.activationRadius) {
          return; // Don't move if player is too far
        }

        // Stop pursuing if player gets too far away
        if (distanceToPlayer > m.userData.pursuitRadius) {
          return; // Don't move if player is beyond pursuit range
        }

        // Rotate entire monster body on Y to face player
        const dir = new THREE.Vector3()
          .subVectors(playerPos, m.position)
          .setY(0)
          .normalize();
        if (dir.length()) {
          m.lookAt(m.position.clone().add(dir));
        }

        // Eye & pupil tracking
        m.traverse(obj => {
          if (obj.name === 'eye' || obj.name === 'pupil') {
            obj.lookAt(playerPos);
          }
        });

        // Step towards player with obstacle avoidance
        // Apply difficulty-based speed for yellow monsters (faster than red)
        const speed = difficulties[currentDifficulty].yellowMonsterSpeed;
        const v = new THREE.Vector3().subVectors(playerPos, m.position).normalize().multiplyScalar(speed);

        const oldPos = m.position.clone();

        ['x', 'z'].forEach(ax => {
          const tp = m.position.clone();
          tp[ax] += v[ax];

          // Check for tree collisions
          if (!checkTreeCollision(tp, monsterCollider.radius)) {
            // Check other colliders
            const monsterSphere = new THREE.Sphere(tp, monsterCollider.radius);
            if (!collidableBoxes.some(b => b.intersectsSphere(monsterSphere))) {
              m.position[ax] += v[ax];
            }
          }
        });

        // Clamp
        m.position.x = Math.max(boundary.min, Math.min(boundary.max, m.position.x));
        m.position.z = Math.max(boundary.min, Math.min(boundary.max, m.position.z));
      });

      // Separate overlaps between yellow monsters
      const sep = 20;
      yellowMonsters.forEach((a, i) => {
        yellowMonsters.forEach((b, j) => {
          if (i >= j) return;
          const d = a.position.distanceTo(b.position);
          if (d < sep) {
            const push = a.position.clone().sub(b.position).normalize().multiplyScalar((sep - d) / 2);
            a.position.add(push);
            b.position.sub(push);
          }
        });
      });

      // Check for catching player (only if not on tree)
      yellowMonsters.forEach(m => {
        if (m.position.distanceTo(controls.getObject().position) < 10 && !won && !lost && !player.onTree) {
          gameOver();
        }
      });
    }

    function resetGame() {
      score = 0;
      won = false;
      lost = false;
      gamePaused = false;
      gameActive = true;
      player.insideBush = false;
      player.onTree = false;
      player.groundLevel = 10;
      scoreEl.textContent = score;
      timeElapsedEl.textContent = "0";

      // Reset player position and physics
      controls.getObject().position.set(0, player.height, 0);
      player.jumping = false;
      player.velocity = 0;
      player.jumpCooldown = 0;

      // Reset red monsters
      monsters.forEach((m, i) => {
        if (i < monsterInitialPositions.length) {
          m.position.copy(monsterInitialPositions[i]);
        }
      });

      // Reset yellow monsters
      yellowMonsters.forEach((m, i) => {
        if (i < yellowMonsterInitialPositions.length) {
          m.position.copy(yellowMonsterInitialPositions[i]);
        }
      });

      // Clean up fireworks
      fireworks.forEach(f => scene.remove(f.mesh));
      fireworks.length = 0;

      frameCount = 0;
      fireworksRunning = false;
    }

    function createMapBoundaries() {
      // Remove any existing boundary meshes labeled as boundary
      scene.children.forEach(child => {
        if (child.userData && child.userData.boundary === true) {
          scene.remove(child);
        }
      });

      // Clear the bushes array
      bushes.length = 0;

      // Create fence posts and railings around the map
      const fenceHeight = 15;
      const postSpacing = 40;
      const numPosts = Math.ceil((boundary.max - boundary.min) * 2 / postSpacing);

      // Materials
      const postMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 }); // Brown
      const railMaterial = new THREE.MeshPhongMaterial({ color: 0xA0522D }); // Lighter brown

      // Post and rail geometries
      const postGeometry = new THREE.BoxGeometry(4, fenceHeight, 4);
      const railGeometry = new THREE.BoxGeometry(postSpacing, 2, 2);

      // Create fence group
      const fenceGroup = new THREE.Group();
      fenceGroup.userData = { boundary: true };

      // Helper function to create a fence segment along one edge
      function createFenceSegment(startX, startZ, direction) {
        const isXAxis = direction === 'x';

        for (let i = 0; i < numPosts; i++) {
          const offset = i * postSpacing;
          const x = isXAxis ? startX + offset : startX;
          const z = isXAxis ? startZ : startZ + offset;

          // Create post
          const post = new THREE.Mesh(postGeometry, postMaterial);
          post.position.set(x, fenceHeight / 2, z);
          fenceGroup.add(post);

          // Create rails (except for the last post)
          if (i < numPosts - 1) {
            // Lower rail
            const lowerRail = new THREE.Mesh(railGeometry, railMaterial);
            lowerRail.position.set(
              isXAxis ? x + postSpacing / 2 : x,
              fenceHeight / 4,
              isXAxis ? z : z + postSpacing / 2
            );
            if (!isXAxis) lowerRail.rotation.y = Math.PI / 2;
            fenceGroup.add(lowerRail);

            // Upper rail
            const upperRail = new THREE.Mesh(railGeometry, railMaterial);
            upperRail.position.set(
              isXAxis ? x + postSpacing / 2 : x,
              fenceHeight * 3 / 4,
              isXAxis ? z : z + postSpacing / 2
            );
            if (!isXAxis) upperRail.rotation.y = Math.PI / 2;
            fenceGroup.add(upperRail);
          }
        }
      }

      // Create fences along all four edges
      createFenceSegment(boundary.min, boundary.min, 'x'); // North edge
      createFenceSegment(boundary.min, boundary.max, 'x'); // South edge
      createFenceSegment(boundary.min, boundary.min, 'z'); // West edge
      createFenceSegment(boundary.max, boundary.min, 'z'); // East edge

      scene.add(fenceGroup);
      addCollider(fenceGroup);

      // Create bushes - player can hide inside
      createBushes();
    }

    function createBushes() {
      // Create bushes around the map that the player can hide in
      // Using user specified sizes

      const bushMaterial = new THREE.MeshPhongMaterial({
        color: 0x228B22, // Forest green
        transparent: true,
        opacity: 0.85 // Slightly transparent to indicate they're special
      });

      // Bush parameters - user specified sizes
      const numBushes = 15;
      const bushMinRadius = 20;
      const bushMaxRadius = 40;
      const bushDistance = 800; // Distance from center to place bushes

      // Create bushes group
      const bushesGroup = new THREE.Group();
      bushesGroup.userData = { boundary: true };

      for (let i = 0; i < numBushes; i++) {
        // Position bushes in a circle around the map
        const angle = (Math.PI * 2 / numBushes) * i;
        const distVariation = Math.random() * 100 - 50;
        const baseX = Math.cos(angle) * (bushDistance + distVariation);
        const baseZ = Math.sin(angle) * (bushDistance + distVariation);

        // Bush dimensions
        const radius = bushMinRadius + Math.random() * (bushMaxRadius - bushMinRadius);
        const height = radius * 0.8; // Flatter bushes

        // Create main bush shape
        const bushGeo = new THREE.SphereGeometry(radius, 12, 12);
        bushGeo.scale(1, 0.6, 1); // Flatten to make it look more like a bush
        bushGeo.translate(0, height * 0.6, 0); // Move up so bottom is at ground level

        const bush = new THREE.Mesh(bushGeo, bushMaterial);
        bush.position.set(baseX, 0, baseZ);
        bush.userData = {
          radius: radius,   // Store radius for collision detection
          isBush: true      // Mark as a bush
        };

        // Add the bush to our bushes array for collision detection
        bushes.push(bush);

        bushesGroup.add(bush);

        // Add some smaller bush shapes to make it look more natural
        const numBumps = Math.floor(Math.random() * 6) + 4;
        for (let j = 0; j < numBumps; j++) {
          const bumpSize = radius * (0.3 + Math.random() * 0.3);
          const bumpAngle = Math.random() * Math.PI * 2;
          const bumpDist = radius * 0.7;

          const bumpX = Math.cos(bumpAngle) * bumpDist;
          const bumpZ = Math.sin(bumpAngle) * bumpDist;
          const bumpY = height * (0.3 + Math.random() * 0.5);

          const bumpGeo = new THREE.SphereGeometry(bumpSize, 6, 6);
          const bump = new THREE.Mesh(bumpGeo, bushMaterial);
          bump.position.set(bumpX, bumpY, bumpZ);
          bush.add(bump);
        }

        // Add some random placement bushes for visual interest
        if (i % 3 === 0) {
          // Create some additional smaller bushes around the main one
          const numSmallBushes = Math.floor(Math.random() * 3) + 1;
          for (let k = 0; k < numSmallBushes; k++) {
            const smallBushAngle = Math.random() * Math.PI * 2;
            const smallBushDist = radius * 1.5 + Math.random() * radius;
            const smallBushX = baseX + Math.cos(smallBushAngle) * smallBushDist;
            const smallBushZ = baseZ + Math.sin(smallBushAngle) * smallBushDist;

            const smallRadius = radius * (0.3 + Math.random() * 0.4);
            const smallHeight = smallRadius * 0.8;

            const smallBushGeo = new THREE.SphereGeometry(smallRadius, 8, 8);
            smallBushGeo.scale(1, 0.6, 1);
            smallBushGeo.translate(0, smallHeight * 0.6, 0);

            const smallBush = new THREE.Mesh(smallBushGeo, bushMaterial);
            smallBush.position.set(smallBushX, 0, smallBushZ);
            smallBush.userData = {
              radius: smallRadius,
              isBush: true
            };

            // Add to bushes array for collision detection
            bushes.push(smallBush);
            bushesGroup.add(smallBush);
          }
        }
      }

      scene.add(bushesGroup);
    }
  </script>
</body>

</html>