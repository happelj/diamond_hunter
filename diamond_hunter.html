<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Diamond Hunter</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Arial', sans-serif;
    }

    /* Game UI Elements */
    #gameUI {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }

    #overlay {
      position: absolute;
      top: 20px;
      left: 20px;
      color: #fff;
      font-size: 24px;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 10px 20px;
      border-radius: 10px;
      z-index: 100;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
    }

    #startScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    #startScreen h1 {
      color: #fff;
      font-size: 48px;
      margin-bottom: 20px;
      text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
    }

    #startButton {
      background-color: #00ffff;
      color: #000;
      font-size: 24px;
      padding: 15px 30px;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
      pointer-events: auto;
    }

    #startButton:hover {
      background-color: #ffffff;
      transform: scale(1.1);
    }

    #gameOverScreen,
    #winScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 900;
    }

    #gameOverScreen h1 {
      color: #ff0000;
      font-size: 60px;
      margin-bottom: 20px;
      text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000;
    }

    #winScreen h1 {
      color: #00ffff;
      font-size: 60px;
      margin-bottom: 20px;
      text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
    }

    .restartButton {
      background-color: #ffffff;
      color: #000;
      font-size: 24px;
      padding: 15px 30px;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
      pointer-events: auto;
      margin-top: 20px;
    }

    .restartButton:hover {
      background-color: #00ffff;
      transform: scale(1.1);
    }

    /* Controls guide */
    #controlsGuide {
      position: absolute;
      bottom: 20px;
      left: 20px;
      color: #fff;
      font-size: 18px;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 10px;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
    }

    /* Timer element */
    #timer {
      position: absolute;
      top: 20px;
      right: 20px;
      color: #fff;
      font-size: 24px;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 10px 20px;
      border-radius: 10px;
      z-index: 100;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
    }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.module.js",
      "three/": "https://cdn.jsdelivr.net/npm/three@0.152.0/"
    }
  }
  </script>
</head>

<body>
  <div id="gameUI">
    <div id="overlay" style="display:none;">Diamonds: <span id="score">0</span>/<span id="totalDiamonds">100</span>
    </div>
    <div id="timer" style="display:none;">Time: <span id="timeElapsed">0</span>s</div>
    <div id="controlsGuide" style="display:none;">
      <strong>Controls:</strong> W,A,S,D to move | Mouse to look | F for fireworks | ESC to pause
    </div>

    <div id="startScreen">
      <h1>DIAMOND HUNTER</h1>
      <button id="startButton">START GAME</button>
    </div>

    <div id="gameOverScreen">
      <h1>GAME OVER</h1>
      <p style="color: #fff; font-size: 24px;">You collected <span id="finalScore">0</span> diamonds</p>
      <button class="restartButton" id="restartButtonGameOver">TRY AGAIN</button>
    </div>

    <div id="winScreen">
      <h1>YOU WIN!</h1>
      <p style="color: #fff; font-size: 24px;">You collected all <span id="winTotalDiamonds">100</span> diamonds in
        <span id="finalTime">0</span> seconds</p>
      <button class="restartButton" id="restartButtonWin">PLAY AGAIN</button>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls.js';

    let camera, scene, renderer, controls;
    const diamonds = [];
    const monsters = [];
    const monsterInitialPositions = [];
    let totalDiamonds = 0;
    let score = 0;
    let won = false;
    let lost = false;
    let gameActive = false;
    let gameTime = 0;
    let gameTimer;

    // Fireworks particle class
    class FireworkParticle {
      constructor(position) {
        const geom = new THREE.SphereGeometry(2, 8, 8);
        const color = new THREE.Color().setHSL(Math.random(), 1.0, 0.5);
        this.mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 });
        this.mesh = new THREE.Mesh(geom, this.mat);
        this.mesh.position.copy(position);
        const dir = new THREE.Vector3((Math.random() * 2 - 1), (Math.random() * 2 - 1), (Math.random() * 2 - 1)).normalize();
        this.vel = dir.multiplyScalar(Math.random() * 4 + 2);
        this.age = 0;
        this.life = Math.random() * 40 + 60;
      }
      update() {
        this.mesh.position.add(this.vel);
        this.vel.y -= 0.1;
        this.age++;
        this.mat.opacity = 1 - this.age / this.life;
        return this.age < this.life;
      }
    }
    const fireworks = [];
    let fireworksRunning = false;
    let frameCount = 0;

    // Collision boxes & settings
    const collidableBoxes = [];
    const boundary = { min: -1000, max: 1000 };
    const playerCollider = { radius: 4 };
    const monsterCollider = { radius: 5 };

    // UI Elements
    let scoreEl;
    let totalDiamondsEl;
    let finalScoreEl;
    let winTotalDiamondsEl;
    let timeElapsedEl;
    let finalTimeEl;
    let overlayEl;
    let timerEl;
    let controlsGuideEl;
    let startScreenEl;
    let gameOverScreenEl;
    let winScreenEl;

    const keys = {};

    init();

    function init() {
      // Get UI elements
      scoreEl = document.getElementById('score');
      totalDiamondsEl = document.getElementById('totalDiamonds');
      finalScoreEl = document.getElementById('finalScore');
      winTotalDiamondsEl = document.getElementById('winTotalDiamonds');
      timeElapsedEl = document.getElementById('timeElapsed');
      finalTimeEl = document.getElementById('finalTime');
      overlayEl = document.getElementById('overlay');
      timerEl = document.getElementById('timer');
      controlsGuideEl = document.getElementById('controlsGuide');
      startScreenEl = document.getElementById('startScreen');
      gameOverScreenEl = document.getElementById('gameOverScreen');
      winScreenEl = document.getElementById('winScreen');

      // Set up buttons
      document.getElementById('startButton').addEventListener('click', startGame);
      document.getElementById('restartButtonGameOver').addEventListener('click', startGame);
      document.getElementById('restartButtonWin').addEventListener('click', startGame);

      // Set up scene
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 2000);
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);
      scene.fog = new THREE.Fog(0x87ceeb, 0, 750);

      const hemi = new THREE.HemisphereLight(0xffffff, 0x444444);
      hemi.position.set(0, 200, 0);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff);
      dir.position.set(0, 200, 100);
      scene.add(dir);

      controls = new PointerLockControls(camera, document.body);
      controls.addEventListener('lock', onLock);
      controls.addEventListener('unlock', onUnlock);
      scene.add(controls.getObject());
      controls.getObject().position.set(0, 10, 0);

      // Floor
      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(2000, 2000, 100, 100).rotateX(-Math.PI / 2),
        new THREE.MeshPhongMaterial({ color: 0x228B22 })
      );
      scene.add(floor);

      // Trees
      spawnObjects('tree', 50, 7, (pos) => {
        const t = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 10, 8), new THREE.MeshPhongMaterial({ color: 0x8b4513 }));
        t.position.set(pos.x, 5, pos.z);
        scene.add(t); addCollider(t);
        const l = new THREE.Mesh(new THREE.SphereGeometry(5, 8, 8), new THREE.MeshPhongMaterial({ color: 0x006400 }));
        l.position.set(pos.x, 12, pos.z);
        scene.add(l); addCollider(l);
      });

      // Mountains (upright cones)
      for (let i = 0; i < 8; i++) {
        const angle = (Math.PI * 2 / 8) * i;
        const radius = 800 + Math.random() * 200;
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        const mountain = new THREE.Mesh(
          new THREE.ConeGeometry(200, 400, 16),
          new THREE.MeshPhongMaterial({ color: 0x555555 })
        );
        mountain.position.set(x, 200, z);
        scene.add(mountain);
        addCollider(mountain);
      }

      // Clouds
      for (let i = 0; i < 20; i++) {
        const cloud = new THREE.Group();
        for (let j = 0; j < 5; j++) {
          const c = new THREE.Mesh(
            new THREE.SphereGeometry(20, 8, 8),
            new THREE.MeshPhongMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 })
          );
          c.position.set(Math.random() * 40 - 20, Math.random() * 10, Math.random() * 40 - 20);
          cloud.add(c);
        }
        cloud.position.set(Math.random() * 1600 - 800, 200 + Math.random() * 100, Math.random() * 1600 - 800);
        scene.add(cloud);
      }

      // Diamonds
      spawnDiamonds(100);
      totalDiamonds = diamonds.length;
      totalDiamondsEl.textContent = totalDiamonds;
      winTotalDiamondsEl.textContent = totalDiamonds;

      // Monsters
      spawnMonsters(10);

      // Renderer
      renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      window.addEventListener('resize', onResize);
      document.addEventListener('keydown', onKey);
      document.addEventListener('keyup', onKey);
      animate();
    }

    function startGame() {
      // Reset everything
      resetGame();

      // Hide UI screens and show game UI
      startScreenEl.style.display = 'none';
      gameOverScreenEl.style.display = 'none';
      winScreenEl.style.display = 'none';

      // Start the timer
      gameTime = 0;
      clearInterval(gameTimer);
      gameTimer = setInterval(() => {
        if (gameActive && !won && !lost) {
          gameTime++;
          timeElapsedEl.textContent = gameTime;
        }
      }, 1000);

      // Lock controls
      controls.lock();
    }

    function onLock() {
      gameActive = true;
      overlayEl.style.display = 'block';
      timerEl.style.display = 'block';
      controlsGuideEl.style.display = 'block';
    }

    function onUnlock() {
      if (gameActive && !won && !lost) {
        // Only pause the game if it's active and not over
        gameActive = false;
        overlayEl.style.display = 'none';
        timerEl.style.display = 'none';
        controlsGuideEl.style.display = 'none';
        startScreenEl.style.display = 'flex';
        document.getElementById('startButton').textContent = 'RESUME GAME';
      }
    }

    function gameOver() {
      gameActive = false;
      lost = true;
      controls.unlock();

      // Show game over screen
      finalScoreEl.textContent = score;
      gameOverScreenEl.style.display = 'flex';

      // Stop timer
      clearInterval(gameTimer);
    }

    function winGame() {
      gameActive = false;
      won = true;
      controls.unlock();

      // Show win screen
      finalTimeEl.textContent = gameTime;
      winScreenEl.style.display = 'flex';

      // Stop timer
      clearInterval(gameTimer);

      // Start victory fireworks
      fireworksRunning = true;

      // Schedule fireworks to stop after 10 seconds
      setTimeout(() => {
        fireworksRunning = false;
      }, 10000);
    }

    function addCollider(mesh) {
      collidableBoxes.push(new THREE.Box3().setFromObject(mesh));
    }

    function spawnObjects(type, count, radius, place) {
      let placed = 0, attempts = 0;
      const maxAtt = count * 100;
      while (placed < count && attempts < maxAtt) {
        attempts++;
        const x = Math.random() * 1000 - 500;
        const z = Math.random() * 1000 - 500;
        const y = (type === 'mountain' ? 200 : 12);
        const pos = new THREE.Vector3(x, y, z);
        const test = new THREE.Sphere(pos, radius);
        if (!collidableBoxes.some(b => b.intersectsSphere(test))) { place(pos); placed++; }
      }
    }

    function spawnDiamonds(count) {
      // Clear any existing diamonds
      diamonds.forEach(d => {
        if (d) scene.remove(d);
      });
      diamonds.length = 0;

      const geo = new THREE.OctahedronGeometry(5);
      const mat = new THREE.MeshPhongMaterial({
        color: 0x00ffff,
        emissive: 0x007777,
        shininess: 100
      });

      let placed = 0, attempts = 0;
      while (placed < count && attempts < count * 50) {
        attempts++;
        const x = Math.random() * 1000 - 500;
        const z = Math.random() * 1000 - 500;
        const pos = new THREE.Vector3(x, 5, z);
        const test = new THREE.Sphere(pos, playerCollider.radius + 1);
        if (!collidableBoxes.some(b => b.intersectsSphere(test))) {
          const d = new THREE.Mesh(geo, mat);
          d.position.copy(pos);
          // Add rotation animation
          d.userData = {
            rotationSpeed: Math.random() * 0.02 + 0.01,
            floatSpeed: Math.random() * 0.01 + 0.005,
            floatHeight: Math.random() * 0.5 + 0.5,
            startY: pos.y
          };
          scene.add(d);
          diamonds.push(d);
          placed++;
        }
      }
    }

    function spawnMonsters(count) {
      // Clear any existing monsters
      monsters.forEach(m => {
        if (m) scene.remove(m);
      });
      monsters.length = 0;
      monsterInitialPositions.length = 0;

      // Monster body
      const bodyGeo = new THREE.BoxGeometry(10, 15, 10);
      const bodyMat = new THREE.MeshPhongMaterial({ color: 0xff0000 });

      // Monster eyes
      const eyeGeo = new THREE.SphereGeometry(1.5, 8, 8);
      const eyeMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
      const pupilMat = new THREE.MeshPhongMaterial({ color: 0x000000 });

      let placed = 0, attempts = 0;
      while (placed < count && attempts < count * 50) {
        attempts++;
        const x = Math.random() * 1000 - 500;
        const z = Math.random() * 1000 - 500;
        const pos = new THREE.Vector3(x, 10, z);
        const test = new THREE.Sphere(pos, monsterCollider.radius + 1);
        if (!collidableBoxes.some(b => b.intersectsSphere(test))) {
          // Create monster group
          const monster = new THREE.Group();

          // Body
          const body = new THREE.Mesh(bodyGeo, bodyMat);
          monster.add(body);

          // Eyes
          const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
          leftEye.position.set(-2.5, 5, 5);
          monster.add(leftEye);

          const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
          rightEye.position.set(2.5, 5, 5);
          monster.add(rightEye);

          // Pupils
          const leftPupil = new THREE.Mesh(new THREE.SphereGeometry(0.7, 8, 8), pupilMat);
          leftPupil.position.set(-2.5, 5, 6);
          monster.add(leftPupil);

          const rightPupil = new THREE.Mesh(new THREE.SphereGeometry(0.7, 8, 8), pupilMat);
          rightPupil.position.set(2.5, 5, 6);
          monster.add(rightPupil);

          monster.position.copy(pos);
          scene.add(monster);
          monsters.push(monster);
          monsterInitialPositions.push(monster.position.clone());
          placed++;
        }
      }
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onKey(e) {
      if (e.code === 'KeyF' && e.type === 'keydown') fireworksRunning = !fireworksRunning;
      keys[e.code] = e.type === 'keydown';
    }

    function animate() {
      requestAnimationFrame(animate);
      frameCount++;

      // Update diamond rotations and floating
      diamonds.forEach(d => {
        if (d) {
          d.rotation.y += d.userData.rotationSpeed;
          d.rotation.x += d.userData.rotationSpeed * 0.5;

          // Floating effect
          d.position.y = d.userData.startY +
            Math.sin(frameCount * d.userData.floatSpeed) * d.userData.floatHeight;
        }
      });

      const fireNow = fireworksRunning || (won && !lost);
      if (fireNow && frameCount % 30 === 0) {
        const burstPos = new THREE.Vector3(
          Math.random() * 800 - 400,
          Math.random() * 100 + 150,
          Math.random() * 800 - 400
        );
        for (let i = 0; i < 40; i++) {
          const p = new FireworkParticle(burstPos);
          scene.add(p.mesh);
          fireworks.push(p);
        }
      }

      // Update particles
      for (let i = fireworks.length - 1; i >= 0; i--) {
        if (!fireworks[i].update()) {
          scene.remove(fireworks[i].mesh);
          fireworks.splice(i, 1);
        }
      }

      if (gameActive && !won && !lost && controls.isLocked) {
        updatePlayer();
        updateDiamonds();
        updateMonsters();
      }

      renderer.render(scene, camera);
    }

    function updatePlayer() {
      const pl = controls.getObject(); pl.position.y = 10;
      const old = pl.position.clone();
      const dlt = 0.1;
      const dir = new THREE.Vector3(
        (keys['KeyD'] ? 1 : 0) - (keys['KeyA'] ? 1 : 0),
        0,
        (keys['KeyS'] ? 1 : 0) - (keys['KeyW'] ? 1 : 0)
      ).normalize();
      if (dir.length()) {
        const v = dir.multiplyScalar(400 * dlt);
        pl.translateX(v.x * dlt);
        pl.translateZ(v.z * dlt);
        pl.position.x = Math.max(boundary.min, Math.min(boundary.max, pl.position.x));
        pl.position.z = Math.max(boundary.min, Math.min(boundary.max, pl.position.z));
        const sph = new THREE.Sphere(pl.position, playerCollider.radius);
        for (const b of collidableBoxes) if (b.intersectsSphere(sph)) { pl.position.copy(old); break; }
      }
    }

    function updateDiamonds() {
      diamonds.forEach((d, i) => {
        if (d && d.position.distanceTo(controls.getObject().position) < 10) {
          scene.remove(d);
          diamonds[i] = null;
          score++;
          scoreEl.textContent = score;

          // Play pickup sound effect
          playPickupSound();

          if (score >= totalDiamonds) {
            winGame();
          }
        }
      });
    }

    function playPickupSound() {
      // Simple audio feedback using Web Audio API
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(880, audioContext.currentTime); // A5
        oscillator.frequency.exponentialRampToValueAtTime(
          1760, audioContext.currentTime + 0.1 // A6
        );

        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.2);
      } catch (e) {
        // Fallback if Web Audio API is not supported
        console.log("Audio feedback not supported");
      }
    }

    function updateMonsters() {
      monsters.forEach(m => {
        // Point eyes at player
        const playerPos = controls.getObject().position;
        m.children.forEach((part, i) => {
          if (i >= 2 && i <= 4) { // Eyes and pupils
            part.lookAt(playerPos);
          }
        });

        // Move towards player
        const v = new THREE.Vector3().subVectors(controls.getObject().position, m.position).
          normalize().multiplyScalar(0.5);
        ['x', 'z'].forEach(ax => {
          const tp = m.position.clone(); tp[ax] += v[ax];
          if (!collidableBoxes.some(b => b.intersectsSphere(new THREE.Sphere(tp, monsterCollider.radius)))) {
            m.position[ax] += v[ax];
          }
        });
        m.position.x = Math.max(boundary.min, Math.min(boundary.max, m.position.x));
        m.position.z = Math.max(boundary.min, Math.min(boundary.max, m.position.z));
      });

      // Separate monsters
      const sep = 20;
      monsters.forEach((a, i) => {
        monsters.forEach((b, j) => {
          if (i >= j) return;
          const d = a.position.distanceTo(b.position);
          if (d < sep) {
            const push = a.position.clone().sub(b.position).
              normalize().multiplyScalar((sep - d) / 2);
            a.position.add(push);
            b.position.sub(push);
          }
        });
      });

      // Check for player collision
      monsters.forEach(m => {
        if (m.position.distanceTo(controls.getObject().position) < 10 && !won && !lost) {
          gameOver();
        }
      });
    }

    function resetGame() {
      score = 0;
      won = false;
      lost = false;
      scoreEl.textContent = score;
      timeElapsedEl.textContent = "0";

      // Reset player position
      controls.getObject().position.set(0, 10, 0);

      // Reset monsters
      monsters.forEach((m, i) => {
        if (i < monsterInitialPositions.length) {
          m.position.copy(monsterInitialPositions[i]);
        }
      });

      // Clean up fireworks
      fireworks.forEach(f => scene.remove(f.mesh));
      fireworks.length = 0;

      frameCount = 0;
      fireworksRunning = false;
    }
  </script>
</body>

</html>