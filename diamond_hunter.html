<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Diamond Hunter</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Arial', sans-serif;
    }

    /* Game UI Elements */
    #gameUI {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }

    #overlay {
      position: absolute;
      top: 20px;
      left: 20px;
      color: #fff;
      font-size: 24px;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 10px 20px;
      border-radius: 10px;
      z-index: 100;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
    }

    #startScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    #startScreen h1 {
      color: #fff;
      font-size: 48px;
      margin-bottom: 20px;
      text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
    }

    #difficultySelector {
      background-color: rgba(0, 0, 0, 0.7);
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 30px;
      pointer-events: auto;
    }

    #difficultySelector h2 {
      color: #fff;
      font-size: 24px;
      margin-top: 0;
      margin-bottom: 15px;
      text-align: center;
    }

    .difficultyOptions {
      display: flex;
      justify-content: center;
      gap: 15px;
    }

    .difficultyBtn {
      background-color: #333;
      color: #fff;
      font-size: 18px;
      padding: 10px 20px;
      border: 2px solid #555;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s;
    }

    .difficultyBtn.selected {
      background-color: #00ffff;
      color: #000;
      border-color: #00ffff;
      transform: scale(1.05);
    }

    .difficultyBtn:hover:not(.selected) {
      background-color: #444;
      border-color: #00ffff;
    }

    #startButton {
      background-color: #00ffff;
      color: #000;
      font-size: 24px;
      padding: 15px 30px;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
      pointer-events: auto;
    }

    #startButton:hover {
      background-color: #ffffff;
      transform: scale(1.1);
    }

    #gameOverScreen,
    #winScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 900;
    }

    #gameOverScreen h1 {
      color: #ff0000;
      font-size: 60px;
      margin-bottom: 20px;
      text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000;
    }

    #winScreen h1 {
      color: #00ffff;
      font-size: 60px;
      margin-bottom: 20px;
      text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
    }

    .restartButton {
      background-color: #ffffff;
      color: #000;
      font-size: 24px;
      padding: 15px 30px;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
      pointer-events: auto;
      margin-top: 20px;
    }

    .restartButton:hover {
      background-color: #00ffff;
      transform: scale(1.1);
    }

    /* Controls guide */
    #controlsGuide {
      position: absolute;
      bottom: 20px;
      left: 20px;
      color: #fff;
      font-size: 18px;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 10px;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
    }

    /* Timer element */
    #timer {
      position: absolute;
      top: 20px;
      right: 20px;
      color: #fff;
      font-size: 24px;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 10px 20px;
      border-radius: 10px;
      z-index: 100;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
    }

    /* Difficulty indicator */
    #difficultyIndicator {
      position: absolute;
      top: 70px;
      right: 20px;
      color: #fff;
      font-size: 18px;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 8px 15px;
      border-radius: 10px;
      z-index: 100;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
      display: none;
    }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.module.js",
      "three/": "https://cdn.jsdelivr.net/npm/three@0.152.0/"
    }
  }
  </script>
</head>

<body>
  <div id="gameUI">
    <div id="overlay" style="display:none;">Diamonds: <span id="score">0</span>/<span id="totalDiamonds">100</span>
    </div>
    <div id="timer" style="display:none;">Time: <span id="timeElapsed">0</span>s</div>
    <div id="difficultyIndicator" style="display:none;">Difficulty: <span id="currentDifficulty">Normal</span></div>
    <div id="controlsGuide" style="display:none;">
      <strong>Controls:</strong> W,A,S,D to move | Mouse to look | F for fireworks | ESC to pause
    </div>

    <div id="startScreen">
      <h1>DIAMOND HUNTER</h1>
      <div id="difficultySelector">
        <h2>SELECT DIFFICULTY</h2>
        <div class="difficultyOptions">
          <button class="difficultyBtn" data-difficulty="easy">Easy</button>
          <button class="difficultyBtn selected" data-difficulty="normal">Normal</button>
          <button class="difficultyBtn" data-difficulty="hard">Hard</button>
        </div>
      </div>
      <button id="startButton">START GAME</button>
    </div>

    <div id="gameOverScreen">
      <h1>GAME OVER</h1>
      <p style="color: #fff; font-size: 24px;">You collected <span id="finalScore">0</span> diamonds</p>
      <p style="color: #fff; font-size: 18px;">Difficulty: <span id="gameOverDifficulty">Normal</span></p>
      <button class="restartButton" id="restartButtonGameOver">TRY AGAIN</button>
    </div>

    <div id="winScreen">
      <h1>YOU WIN!</h1>
      <p style="color: #fff; font-size: 24px;">You collected all <span id="winTotalDiamonds">100</span> diamonds in
        <span id="finalTime">0</span> seconds
      </p>
      <p style="color: #fff; font-size: 18px;">Difficulty: <span id="winDifficulty">Normal</span></p>
      <button class="restartButton" id="restartButtonWin">PLAY AGAIN</button>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls.js';

    let camera, scene, renderer, controls;
    const diamonds = [];
    const monsters = [];
    const monsterInitialPositions = [];
    let totalDiamonds = 0;
    let score = 0;
    let won = false;
    let lost = false;
    let gameActive = false;
    let gamePaused = false;
    let gameTime = 0;
    let gameTimer;

    // Difficulty settings
    const difficulties = {
      easy: { monsterSpeed: 0.25, name: "Easy" },
      normal: { monsterSpeed: 0.5, name: "Normal" },
      hard: { monsterSpeed: 0.8, name: "Hard" }
    };
    let currentDifficulty = "normal";

    // Player physics for jumping
    const player = {
      height: 10,           // Player's height off the ground
      jumping: false,       // Is player currently jumping?
      jumpHeight: 60,       // Maximum jump height
      jumpSpeed: 2,         // Jump velocity
      gravity: 0.07,        // Gravity force pulling down
      velocity: 0,          // Current vertical velocity
      jumpCooldown: 0       // Cooldown timer for jumps
    };

    // Fireworks particle class
    class FireworkParticle {
      constructor(position) {
        const geom = new THREE.SphereGeometry(2, 8, 8);
        const color = new THREE.Color().setHSL(Math.random(), 1.0, 0.5);
        this.mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 });
        this.mesh = new THREE.Mesh(geom, this.mat);
        this.mesh.position.copy(position);
        const dir = new THREE.Vector3((Math.random() * 2 - 1), (Math.random() * 2 - 1), (Math.random() * 2 - 1)).normalize();
        this.vel = dir.multiplyScalar(Math.random() * 4 + 2);
        this.age = 0;
        this.life = Math.random() * 40 + 60;
      }
      update() {
        this.mesh.position.add(this.vel);
        this.vel.y -= 0.1;
        this.age++;
        this.mat.opacity = 1 - this.age / this.life;
        return this.age < this.life;
      }
    }
    const fireworks = [];
    let fireworksRunning = false;
    let frameCount = 0;

    // Collision boxes & settings
    const collidableBoxes = [];
    const boundary = { min: -900, max: 900 }; // Reduced for mountain barrier
    const playerCollider = { radius: 4 };
    const monsterCollider = { radius: 5 };

    // UI Elements
    let scoreEl;
    let totalDiamondsEl;
    let finalScoreEl;
    let winTotalDiamondsEl;
    let timeElapsedEl;
    let finalTimeEl;
    let overlayEl;
    let timerEl;
    let controlsGuideEl;
    let startScreenEl;
    let gameOverScreenEl;
    let winScreenEl;
    let difficultyIndicatorEl;
    let currentDifficultyEl;
    let gameOverDifficultyEl;
    let winDifficultyEl;
    let difficultyBtns;

    const keys = {};

    init();

    function init() {
      // Get UI elements
      scoreEl = document.getElementById('score');
      totalDiamondsEl = document.getElementById('totalDiamonds');
      finalScoreEl = document.getElementById('finalScore');
      winTotalDiamondsEl = document.getElementById('winTotalDiamonds');
      timeElapsedEl = document.getElementById('timeElapsed');
      finalTimeEl = document.getElementById('finalTime');
      overlayEl = document.getElementById('overlay');
      timerEl = document.getElementById('timer');
      controlsGuideEl = document.getElementById('controlsGuide');
      startScreenEl = document.getElementById('startScreen');
      gameOverScreenEl = document.getElementById('gameOverScreen');
      winScreenEl = document.getElementById('winScreen');
      difficultyIndicatorEl = document.getElementById('difficultyIndicator');
      currentDifficultyEl = document.getElementById('currentDifficulty');
      gameOverDifficultyEl = document.getElementById('gameOverDifficulty');
      winDifficultyEl = document.getElementById('winDifficulty');
      difficultyBtns = document.querySelectorAll('.difficultyBtn');

      // Set up difficulty selection
      difficultyBtns.forEach(btn => {
        btn.addEventListener('click', () => {
          difficultyBtns.forEach(b => b.classList.remove('selected'));
          btn.classList.add('selected');
          currentDifficulty = btn.dataset.difficulty;
        });
      });

      // Set up buttons
      document.getElementById('startButton').addEventListener('click', () => {
        if (gamePaused) {
          resumeGame();
        } else {
          startGame();
        }
      });
      document.getElementById('restartButtonGameOver').addEventListener('click', startGame);
      document.getElementById('restartButtonWin').addEventListener('click', startGame);

      // Set up scene
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 2000);
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);
      scene.fog = new THREE.Fog(0x87ceeb, 0, 750);

      const hemi = new THREE.HemisphereLight(0xffffff, 0x444444);
      hemi.position.set(0, 200, 0);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff);
      dir.position.set(0, 200, 100);
      scene.add(dir);

      controls = new PointerLockControls(camera, document.body);
      controls.addEventListener('lock', onLock);
      controls.addEventListener('unlock', onUnlock);
      scene.add(controls.getObject());
      controls.getObject().position.set(0, 10, 0);

      // Floor
      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(2000, 2000, 100, 100).rotateX(-Math.PI / 2),
        new THREE.MeshPhongMaterial({ color: 0x228B22 })
      );
      scene.add(floor);

      // Trees - scattered around the main playing area (not on hills)
      spawnObjects('tree', 50, 7, (pos) => {
        const t = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 10, 8), new THREE.MeshPhongMaterial({ color: 0x8b4513 }));
        t.position.set(pos.x, 5, pos.z);
        scene.add(t); addCollider(t);
        const l = new THREE.Mesh(new THREE.SphereGeometry(5, 8, 8), new THREE.MeshPhongMaterial({ color: 0x006400 }));
        l.position.set(pos.x, 12, pos.z);
        scene.add(l); addCollider(l);
      });

      // Clouds
      for (let i = 0; i < 20; i++) {
        const cloud = new THREE.Group();
        for (let j = 0; j < 5; j++) {
          const c = new THREE.Mesh(
            new THREE.SphereGeometry(20, 8, 8),
            new THREE.MeshPhongMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 })
          );
          c.position.set(Math.random() * 40 - 20, Math.random() * 10, Math.random() * 40 - 20);
          cloud.add(c);
        }
        cloud.position.set(Math.random() * 1600 - 800, 200 + Math.random() * 100, Math.random() * 1600 - 800);
        scene.add(cloud);
      }

      // Diamonds
      spawnDiamonds(100);
      totalDiamonds = diamonds.length;
      totalDiamondsEl.textContent = totalDiamonds;
      winTotalDiamondsEl.textContent = totalDiamonds;

      // Monsters
      spawnMonsters(10);

      // Set up map boundaries - fence and hills
      createMapBoundaries();

      // Renderer
      renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      window.addEventListener('resize', onResize);
      document.addEventListener('keydown', onKey);
      document.addEventListener('keyup', onKey);
      animate();
    }

    function startGame() {
      // Reset everything
      resetGame();

      // Create new set of diamonds
      spawnDiamonds(100);
      totalDiamonds = diamonds.length;
      totalDiamondsEl.textContent = totalDiamonds;
      winTotalDiamondsEl.textContent = totalDiamonds;

      // Hide UI screens and show game UI
      startScreenEl.style.display = 'none';
      gameOverScreenEl.style.display = 'none';
      winScreenEl.style.display = 'none';

      // Start the timer
      gameTime = 0;
      clearInterval(gameTimer);
      gameTimer = setInterval(() => {
        if (gameActive && !won && !lost && !gamePaused) {
          gameTime++;
          timeElapsedEl.textContent = gameTime;
        }
      }, 1000);

      // Set game flags
      gameActive = true;
      gamePaused = false;

      // Update difficulty display
      currentDifficultyEl.textContent = difficulties[currentDifficulty].name;
      gameOverDifficultyEl.textContent = difficulties[currentDifficulty].name;
      winDifficultyEl.textContent = difficulties[currentDifficulty].name;

      // Lock controls
      controls.lock();
    }

    function pauseGame() {
      if (gameActive && !won && !lost) {
        gamePaused = true;
        controls.unlock();

        // Show pause screen
        overlayEl.style.display = 'none';
        timerEl.style.display = 'none';
        difficultyIndicatorEl.style.display = 'none';
        controlsGuideEl.style.display = 'none';
        startScreenEl.style.display = 'flex';
        document.getElementById('startButton').textContent = 'RESUME GAME';
      }
    }

    function resumeGame() {
      if (gamePaused) {
        gamePaused = false;
        startScreenEl.style.display = 'none';

        // This is the fix for the resume bug:
        // We need to explicitly show the UI elements again
        overlayEl.style.display = 'block';
        timerEl.style.display = 'block';
        difficultyIndicatorEl.style.display = 'block';
        controlsGuideEl.style.display = 'block';

        controls.lock();
      }
    }

    function onLock() {
      overlayEl.style.display = 'block';
      timerEl.style.display = 'block';
      difficultyIndicatorEl.style.display = 'block';
      controlsGuideEl.style.display = 'block';
    }

    function onUnlock() {
      if (gameActive && !won && !lost && !gamePaused) {
        pauseGame();
      }
    }

    function gameOver() {
      gameActive = false;
      lost = true;
      gamePaused = false;
      controls.unlock();

      // Show game over screen
      finalScoreEl.textContent = score;
      gameOverDifficultyEl.textContent = difficulties[currentDifficulty].name;
      gameOverScreenEl.style.display = 'flex';

      // Stop timer
      clearInterval(gameTimer);
    }

    function winGame() {
      gameActive = false;
      won = true;
      gamePaused = false;
      controls.unlock();

      // Show win screen
      finalTimeEl.textContent = gameTime;
      winDifficultyEl.textContent = difficulties[currentDifficulty].name;
      winScreenEl.style.display = 'flex';

      // Stop timer
      clearInterval(gameTimer);

      // Start victory fireworks
      fireworksRunning = true;

      // Schedule fireworks to stop after 10 seconds
      setTimeout(() => {
        fireworksRunning = false;
      }, 10000);
    }

    function addCollider(mesh) {
      // If it's a group, add colliders for each child that's a mesh
      if (mesh.isGroup) {
        mesh.traverse(child => {
          if (child.isMesh) {
            collidableBoxes.push(new THREE.Box3().setFromObject(child));
          }
        });
      } else {
        collidableBoxes.push(new THREE.Box3().setFromObject(mesh));
      }
    }

    function spawnObjects(type, count, radius, place) {
      let placed = 0, attempts = 0;
      const maxAtt = count * 100;
      while (placed < count && attempts < maxAtt) {
        attempts++;
        const x = Math.random() * 1000 - 500;
        const z = Math.random() * 1000 - 500;
        const y = (type === 'mountain' ? 200 : 12);
        const pos = new THREE.Vector3(x, y, z);
        const test = new THREE.Sphere(pos, radius);
        if (!collidableBoxes.some(b => b.intersectsSphere(test))) { place(pos); placed++; }
      }
    }

    function spawnDiamonds(count) {
      // Clear any existing diamonds
      diamonds.forEach(d => {
        if (d) scene.remove(d);
      });
      diamonds.length = 0;

      const geo = new THREE.OctahedronGeometry(5);
      const mat = new THREE.MeshPhongMaterial({
        color: 0x00ffff,
        emissive: 0x007777,
        shininess: 100
      });

      let placed = 0;
      let attempts = 0;
      const maxAttempts = count * 100; // safety limit to prevent infinite loops

      while (placed < count && attempts < maxAttempts) {
        attempts++;
        const x = Math.random() * 1600 - 800;
        const z = Math.random() * 1600 - 800;
        const pos = new THREE.Vector3(x, 5, z);

        // Make sure the diamond doesn't spawn inside objects or outside boundary
        if (x < boundary.min || x > boundary.max || z < boundary.min || z > boundary.max) {
          continue; // Skip positions outside boundary
        }

        // Test sphere so the diamond doesn't spawn inside trees/mountains
        const testSphere = new THREE.Sphere(pos, playerCollider.radius + 1);
        if (!collidableBoxes.some(b => b.intersectsSphere(testSphere))) {
          const d = new THREE.Mesh(geo, mat);
          d.position.copy(pos);
          d.userData = {
            rotationSpeed: Math.random() * 0.02 + 0.01,
            floatSpeed: Math.random() * 0.01 + 0.005,
            floatHeight: Math.random() * 0.5 + 0.5,
            startY: pos.y
          };
          scene.add(d);
          diamonds.push(d);
          placed++;
        }
      }

      // If we couldn't place all diamonds, log a warning
      if (placed < count) {
        console.warn(`Could only place ${placed} out of ${count} diamonds`);
      }

      return placed; // Return the number of diamonds actually placed
    }

    function spawnMonsters(count) {
      monsters.forEach(m => m && scene.remove(m));
      monsters.length = 0; monsterInitialPositions.length = 0;
      const bodyGeo = new THREE.BoxGeometry(10, 15, 10),
        bodyMat = new THREE.MeshPhongMaterial({ color: 0xff0000 }),
        eyeGeo = new THREE.SphereGeometry(1.5, 8, 8),
        eyeMat = new THREE.MeshPhongMaterial({ color: 0xffffff }),
        pupilGeo = new THREE.SphereGeometry(0.7, 8, 8),
        pupilMat = new THREE.MeshPhongMaterial({ color: 0x000000 });
      let placed = 0, attempts = 0;
      while (placed < count && attempts < count * 50) {
        attempts++;
        const x = Math.random() * 1000 - 500, z = Math.random() * 1000 - 500;
        const pos = new THREE.Vector3(x, 10, z);
        if (!collidableBoxes.some(b => b.intersectsSphere(new THREE.Sphere(pos, monsterCollider.radius + 1)))) {
          const mg = new THREE.Group();
          // Body
          const body = new THREE.Mesh(bodyGeo, bodyMat);
          mg.add(body);
          // Eyes (named)
          const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
          leftEye.name = 'eye';
          leftEye.position.set(-2.5, 5, 5);
          mg.add(leftEye);
          const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
          rightEye.name = 'eye';
          rightEye.position.set(2.5, 5, 5);
          mg.add(rightEye);
          // Pupils (named)
          const leftPupil = new THREE.Mesh(pupilGeo, pupilMat);
          leftPupil.name = 'pupil';
          leftPupil.position.set(-2.5, 5, 6);
          mg.add(leftPupil);
          const rightPupil = new THREE.Mesh(pupilGeo, pupilMat);
          rightPupil.name = 'pupil';
          rightPupil.position.set(2.5, 5, 6);
          mg.add(rightPupil);

          mg.position.copy(pos);
          scene.add(mg);
          monsters.push(mg);
          monsterInitialPositions.push(pos.clone());
          placed++;
        }
      }
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onKey(e) {
      if (e.code === 'KeyF' && e.type === 'keydown') fireworksRunning = !fireworksRunning;
      if (e.code === 'Escape' && e.type === 'keydown' && gameActive && !won && !lost) {
        if (gamePaused) {
          resumeGame();
        } else {
          pauseGame();
        }
      }

      // Track all key states
      keys[e.code] = e.type === 'keydown';

      // Prevent spacebar from scrolling the page
      if (e.code === 'Space') {
        e.preventDefault();
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      frameCount++;

      // Update diamond rotations and floating
      diamonds.forEach(d => {
        if (d) {
          d.rotation.y += d.userData.rotationSpeed;
          d.rotation.x += d.userData.rotationSpeed * 0.5;

          // Floating effect
          d.position.y = d.userData.startY +
            Math.sin(frameCount * d.userData.floatSpeed) * d.userData.floatHeight;
        }
      });

      const fireNow = fireworksRunning || (won && !lost);
      if (fireNow && frameCount % 30 === 0) {
        const burstPos = new THREE.Vector3(
          Math.random() * 800 - 400,
          Math.random() * 100 + 150,
          Math.random() * 800 - 400
        );
        for (let i = 0; i < 40; i++) {
          const p = new FireworkParticle(burstPos);
          scene.add(p.mesh);
          fireworks.push(p);
        }
      }

      // Update particles
      for (let i = fireworks.length - 1; i >= 0; i--) {
        if (!fireworks[i].update()) {
          scene.remove(fireworks[i].mesh);
          fireworks.splice(i, 1);
        }
      }

      if (gameActive && !won && !lost && !gamePaused && controls.isLocked) {
        updatePlayer();
        updateDiamonds();
        updateMonsters();
      }

      renderer.render(scene, camera);
    }

    function updatePlayer() {
      const pl = controls.getObject();

      // Handle jumping physics
      if (player.jumping) {
        // Apply velocity and gravity
        player.velocity -= player.gravity;
        pl.position.y += player.velocity;

        // Check if we've hit the ground
        if (pl.position.y <= player.height) {
          pl.position.y = player.height;
          player.jumping = false;
          player.velocity = 0;
          player.jumpCooldown = 10; // Set a short cooldown before next jump
        }
      } else {
        // Ensure player is at correct height when not jumping
        pl.position.y = player.height;

        // Handle jump initiation
        if (keys['Space'] && player.jumpCooldown <= 0) {
          player.jumping = true;
          player.velocity = player.jumpSpeed;

          // Play jump sound
          playJumpSound();
        }
      }

      // Update jump cooldown
      if (player.jumpCooldown > 0) {
        player.jumpCooldown--;
      }

      // Movement
      const old = pl.position.clone();
      const dlt = 0.1;
      const dir = new THREE.Vector3(
        (keys['KeyD'] ? 1 : 0) - (keys['KeyA'] ? 1 : 0),
        0,
        (keys['KeyS'] ? 1 : 0) - (keys['KeyW'] ? 1 : 0)
      ).normalize();

      if (dir.length()) {
        const v = dir.multiplyScalar(400 * dlt);
        pl.translateX(v.x * dlt);
        pl.translateZ(v.z * dlt);
        pl.position.x = Math.max(boundary.min, Math.min(boundary.max, pl.position.x));
        pl.position.z = Math.max(boundary.min, Math.min(boundary.max, pl.position.z));
        const sph = new THREE.Sphere(pl.position, playerCollider.radius);
        for (const b of collidableBoxes) if (b.intersectsSphere(sph)) { pl.position.copy(old); break; }
      }
    }

    function updateDiamonds() {
      diamonds.forEach((d, i) => {
        if (d && d.position.distanceTo(controls.getObject().position) < 10) {
          scene.remove(d);
          diamonds[i] = null;
          score++;
          scoreEl.textContent = score;

          // Play pickup sound effect
          playPickupSound();

          if (score >= totalDiamonds) {
            winGame();
          }
        }
      });
    }

    function playPickupSound() {
      // Simple audio feedback using Web Audio API
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(880, audioContext.currentTime); // A5
        oscillator.frequency.exponentialRampToValueAtTime(
          1760, audioContext.currentTime + 0.1 // A6
        );

        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.2);
      } catch (e) {
        // Fallback if Web Audio API is not supported
        console.log("Audio feedback not supported");
      }
    }

    function playJumpSound() {
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.type = 'square';
        oscillator.frequency.setValueAtTime(220, audioContext.currentTime); // A3
        oscillator.frequency.exponentialRampToValueAtTime(
          440, audioContext.currentTime + 0.1 // A4
        );

        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.3);
      } catch (e) {
        // Fallback if Web Audio API is not supported
        console.log("Audio feedback not supported");
      }
    }

    function updateMonsters() {
      const playerPos = controls.getObject().position;
      monsters.forEach(m => {
        // Rotate entire monster body on Y to face player
        const dir = new THREE.Vector3()
          .subVectors(playerPos, m.position)
          .setY(0)
          .normalize();
        if (dir.length()) {
          m.lookAt(m.position.clone().add(dir));
        }

        // Eye & pupil tracking
        m.traverse(obj => {
          if (obj.name === 'eye' || obj.name === 'pupil') {
            obj.lookAt(playerPos);
          }
        });

        // Step towards player with obstacle avoidance
        // Apply difficulty-based speed
        const speed = difficulties[currentDifficulty].monsterSpeed;
        const v = new THREE.Vector3().subVectors(playerPos, m.position).normalize().multiplyScalar(speed);

        ['x', 'z'].forEach(ax => {
          const tp = m.position.clone();
          tp[ax] += v[ax];
          if (!collidableBoxes.some(b => b.intersectsSphere(new THREE.Sphere(tp, monsterCollider.radius)))) {
            m.position[ax] += v[ax];
          }
        });
        // Clamp
        m.position.x = Math.max(boundary.min, Math.min(boundary.max, m.position.x));
        m.position.z = Math.max(boundary.min, Math.min(boundary.max, m.position.z));
      });

      // Separate overlaps
      const sep = 20;
      monsters.forEach((a, i) => {
        monsters.forEach((b, j) => {
          if (i >= j) return;
          const d = a.position.distanceTo(b.position);
          if (d < sep) {
            const push = a.position.clone().sub(b.position).normalize().multiplyScalar((sep - d) / 2);
            a.position.add(push);
            b.position.sub(push);
          }
        });
      });

      // Check for catching player
      monsters.forEach(m => {
        if (m.position.distanceTo(controls.getObject().position) < 10 && !won && !lost) {
          gameOver();
        }
      });
    }

    function resetGame() {
      score = 0;
      won = false;
      lost = false;
      gamePaused = false;
      gameActive = true;
      scoreEl.textContent = score;
      timeElapsedEl.textContent = "0";

      // Reset player position and physics
      controls.getObject().position.set(0, player.height, 0);
      player.jumping = false;
      player.velocity = 0;
      player.jumpCooldown = 0;

      // Reset monsters
      monsters.forEach((m, i) => {
        if (i < monsterInitialPositions.length) {
          m.position.copy(monsterInitialPositions[i]);
        }
      });

      // Clean up fireworks
      fireworks.forEach(f => scene.remove(f.mesh));
      fireworks.length = 0;

      frameCount = 0;
      fireworksRunning = false;
    }

    function createMapBoundaries() {
      // Remove any existing boundary meshes labeled as boundary
      scene.children.forEach(child => {
        if (child.userData && child.userData.boundary === true) {
          scene.remove(child);
        }
      });

      // Create fence posts and railings around the map
      const fenceHeight = 15;
      const postSpacing = 40;
      const numPosts = Math.ceil((boundary.max - boundary.min) * 2 / postSpacing);

      // Materials
      const postMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 }); // Brown
      const railMaterial = new THREE.MeshPhongMaterial({ color: 0xA0522D }); // Lighter brown

      // Post and rail geometries
      const postGeometry = new THREE.BoxGeometry(4, fenceHeight, 4);
      const railGeometry = new THREE.BoxGeometry(postSpacing, 2, 2);

      // Create fence group
      const fenceGroup = new THREE.Group();
      fenceGroup.userData = { boundary: true };

      // Helper function to create a fence segment along one edge
      function createFenceSegment(startX, startZ, direction) {
        const isXAxis = direction === 'x';

        for (let i = 0; i < numPosts; i++) {
          const offset = i * postSpacing;
          const x = isXAxis ? startX + offset : startX;
          const z = isXAxis ? startZ : startZ + offset;

          // Create post
          const post = new THREE.Mesh(postGeometry, postMaterial);
          post.position.set(x, fenceHeight / 2, z);
          fenceGroup.add(post);

          // Create rails (except for the last post)
          if (i < numPosts - 1) {
            // Lower rail
            const lowerRail = new THREE.Mesh(railGeometry, railMaterial);
            lowerRail.position.set(
              isXAxis ? x + postSpacing / 2 : x,
              fenceHeight / 4,
              isXAxis ? z : z + postSpacing / 2
            );
            if (!isXAxis) lowerRail.rotation.y = Math.PI / 2;
            fenceGroup.add(lowerRail);

            // Upper rail
            const upperRail = new THREE.Mesh(railGeometry, railMaterial);
            upperRail.position.set(
              isXAxis ? x + postSpacing / 2 : x,
              fenceHeight * 3 / 4,
              isXAxis ? z : z + postSpacing / 2
            );
            if (!isXAxis) upperRail.rotation.y = Math.PI / 2;
            fenceGroup.add(upperRail);
          }
        }
      }

      // Create fences along all four edges
      createFenceSegment(boundary.min, boundary.min, 'x'); // North edge
      createFenceSegment(boundary.min, boundary.max, 'x'); // South edge
      createFenceSegment(boundary.min, boundary.min, 'z'); // West edge
      createFenceSegment(boundary.max, boundary.min, 'z'); // East edge

      scene.add(fenceGroup);
      addCollider(fenceGroup);

      // Create hills with trees
      createHills();
    }

    function createHills() {
      // Create some green hills around the map
      const hillMaterial = new THREE.MeshPhongMaterial({ color: 0x228B22 }); // Forest green

      // Hill parameters
      const numHills = 16;
      const hillMinRadius = 30;
      const hillMaxRadius = 60;
      const hillMinHeight = 15;
      const hillMaxHeight = 40;
      const hillDistance = 800; // Distance from center to place hills

      // Create hills group
      const hillsGroup = new THREE.Group();
      hillsGroup.userData = { boundary: true };

      for (let i = 0; i < numHills; i++) {
        // Position hills in a circle near the boundaries
        const angle = (Math.PI * 2 / numHills) * i;
        const distVariation = Math.random() * 100 - 50;
        const baseX = Math.cos(angle) * (hillDistance + distVariation);
        const baseZ = Math.sin(angle) * (hillDistance + distVariation);

        // Hill dimensions
        const radius = hillMinRadius + Math.random() * (hillMaxRadius - hillMinRadius);
        const height = hillMinHeight + Math.random() * (hillMaxHeight - hillMinHeight);

        // Create hill
        const hillGeo = new THREE.SphereGeometry(radius, 16, 16);
        hillGeo.scale(1, height / radius, 1); // Flatten to make it look like a hill
        hillGeo.translate(0, height / 2 - 5, 0); // Lower into the ground slightly

        const hill = new THREE.Mesh(hillGeo, hillMaterial);
        hill.position.set(baseX, 0, baseZ);
        hillsGroup.add(hill);
      }

      scene.add(hillsGroup);
      addCollider(hillsGroup);
    }
  </script>
</body>

</html>