<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Diamond Hunter</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: 'Arial', sans-serif; }
    /* Game UI Elements */
    #gameUI { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
    #overlay { position: absolute; top: 20px; left: 20px; color: #fff; font-size: 24px;
               background-color: rgba(0,0,0,0.5); padding: 10px 20px; border-radius: 10px;
               z-index:100; text-shadow:2px 2px 4px rgba(0,0,0,0.7); display:none; }
    #timer { position: absolute; top:20px; right:20px; color:#fff; font-size:24px;
             background-color:rgba(0,0,0,0.5); padding:10px 20px; border-radius:10px;
             z-index:100; text-shadow:2px 2px 4px rgba(0,0,0,0.7); display:none; }
    #controlsGuide { position:absolute; bottom:20px; left:20px; color:#fff; font-size:18px;
                     background-color:rgba(0,0,0,0.5); padding:10px; border-radius:10px;
                     text-shadow:1px 1px 2px rgba(0,0,0,0.7); display:none; }
    /* Start/End screens */
    #startScreen, #gameOverScreen, #winScreen {
      position:absolute; top:0; left:0; width:100%; height:100%; display:flex;
      flex-direction:column; justify-content:center; align-items:center;
      background-color:rgba(0,0,0,0.7); z-index:900; pointer-events:auto;
    }
    #gameOverScreen, #winScreen { display:none; }
    #startScreen h1, #gameOverScreen h1, #winScreen h1 { color:#fff; font-size:48px; margin-bottom:20px; }
    #winScreen h1 { color:#00ffff; text-shadow:0 0 10px #00ffff,0 0 20px #00ffff; }
    #gameOverScreen h1 { color:#ff0000; text-shadow:0 0 10px #ff0000,0 0 20px #ff0000; }
    #startButton, .restartButton {
      background-color:#00ffff; color:#000; font-size:24px; padding:15px 30px;
      border:none; border-radius:10px; cursor:pointer; transition:all 0.3s; pointer-events:auto;
    }
    #startButton:hover, .restartButton:hover { background-color:#fff; transform:scale(1.1); }
  </style>
  <script type="importmap">
  {"imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.module.js",
    "three/": "https://cdn.jsdelivr.net/npm/three@0.152.0/"
  }}
  </script>
</head>
<body>
  <div id="gameUI">
    <div id="overlay">Diamonds: <span id="score">0</span>/<span id="totalDiamonds">0</span></div>
    <div id="timer">Time: <span id="timeElapsed">0</span>s</div>
    <div id="controlsGuide"><strong>Controls:</strong> W,A,S,D to move | Mouse to look | F for fireworks | ESC to pause</div>

    <div id="startScreen">
      <h1>DIAMOND HUNTER</h1>
      <button id="startButton">START GAME</button>
    </div>

    <div id="gameOverScreen">
      <h1>GAME OVER</h1>
      <p style="color:#fff;font-size:24px;">You collected <span id="finalScore">0</span> diamonds</p>
      <button class="restartButton" id="restartButtonGameOver">TRY AGAIN</button>
    </div>

    <div id="winScreen">
      <h1>YOU WIN!</h1>
      <p style="color:#fff;font-size:24px;">All <span id="winTotalDiamonds">0</span> diamonds in <span id="finalTime">0</span>s</p>
      <button class="restartButton" id="restartButtonWin">PLAY AGAIN</button>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls.js';

    // Core scene & game variables
    let camera, scene, renderer, controls;
    const diamonds = [], monsters = [], monsterInitialPositions = [];
    let totalDiamonds = 0, score = 0, won = false, lost = false;
    let gameActive = false, gameTime = 0, frameCount = 0, fireworksRunning = false, gameTimer;
    const collidableBoxes = [], keys = {};
    const boundary = { min: -1000, max: 1000 };
    const playerCollider = { radius: 4 }, monsterCollider = { radius: 5 };

    // UI references
    let scoreEl, totalDiamondsEl, finalScoreEl, winTotalDiamondsEl, timeElapsedEl, finalTimeEl;
    let overlayEl, timerEl, controlsGuideEl, startScreenEl, gameOverScreenEl, winScreenEl;

    // Firework particle class
    class FireworkParticle {
      constructor(pos) {
        const geom = new THREE.SphereGeometry(2,8,8);
        this.mat = new THREE.MeshBasicMaterial({
          color: new THREE.Color().setHSL(Math.random(),1,0.5),
          transparent: true, opacity: 1
        });
        this.mesh = new THREE.Mesh(geom, this.mat);
        this.mesh.position.copy(pos);
        const dir = new THREE.Vector3(
          Math.random()*2-1, Math.random()*2-1, Math.random()*2-1
        ).normalize();
        this.vel = dir.multiplyScalar(Math.random()*4+2);
        this.age = 0; this.life = Math.random()*40+60;
      }
      update() {
        this.mesh.position.add(this.vel);
        this.vel.y -= 0.1;
        this.age++;
        this.mat.opacity = 1 - this.age/this.life;
        return this.age < this.life;
      }
    }
    const fireworks = [];

    init();

    function init() {
      // Grab UI elements
      scoreEl = document.getElementById('score');
      totalDiamondsEl = document.getElementById('totalDiamonds');
      finalScoreEl = document.getElementById('finalScore');
      winTotalDiamondsEl = document.getElementById('winTotalDiamonds');
      timeElapsedEl = document.getElementById('timeElapsed');
      finalTimeEl = document.getElementById('finalTime');
      overlayEl = document.getElementById('overlay');
      timerEl = document.getElementById('timer');
      controlsGuideEl = document.getElementById('controlsGuide');
      startScreenEl = document.getElementById('startScreen');
      gameOverScreenEl = document.getElementById('gameOverScreen');
      winScreenEl = document.getElementById('winScreen');

      // Button handlers
      document.getElementById('startButton').onclick = startGame;
      document.getElementById('restartButtonGameOver').onclick = startGame;
      document.getElementById('restartButtonWin').onclick = startGame;

      // THREE.js basic setup
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 2000);
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);
      scene.fog = new THREE.Fog(0x87ceeb, 0, 750);

      const hemi = new THREE.HemisphereLight(0xffffff, 0x444444);
      hemi.position.set(0,200,0);
      scene.add(hemi);
      const dirLight = new THREE.DirectionalLight(0xffffff);
      dirLight.position.set(0,200,100);
      scene.add(dirLight);

      controls = new PointerLockControls(camera, document.body);
      controls.addEventListener('lock', onLock);
      controls.addEventListener('unlock', onUnlock);
      scene.add(controls.getObject());
      controls.getObject().position.set(0,10,0);

      // Floor
      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(2000,2000,100,100).rotateX(-Math.PI/2),
        new THREE.MeshPhongMaterial({ color: 0x228B22 })
      );
      scene.add(floor);

      // Trees
      spawnObjects('tree', 50, 7, pos => {
        const trunk = new THREE.Mesh(
          new THREE.CylinderGeometry(1,1,10,8),
          new THREE.MeshPhongMaterial({ color: 0x8b4513 })
        );
        trunk.position.set(pos.x,5,pos.z);
        scene.add(trunk);
        collidableBoxes.push(new THREE.Box3().setFromObject(trunk));

        const leaves = new THREE.Mesh(
          new THREE.SphereGeometry(5,8,8),
          new THREE.MeshPhongMaterial({ color: 0x006400 })
        );
        leaves.position.set(pos.x,12,pos.z);
        scene.add(leaves);
        collidableBoxes.push(new THREE.Box3().setFromObject(leaves));
      });

      // Mountains
      for (let i=0; i<8; i++) {
        const angle = (Math.PI*2/8)*i;
        const radius = 800 + Math.random()*200;
        const mtn = new THREE.Mesh(
          new THREE.ConeGeometry(200,400,16),
          new THREE.MeshPhongMaterial({ color: 0x555555 })
        );
        mtn.position.set(Math.cos(angle)*radius, 200, Math.sin(angle)*radius);
        scene.add(mtn);
        collidableBoxes.push(new THREE.Box3().setFromObject(mtn));
      }

      // Clouds
      for (let i=0; i<20; i++) {
        const cloud = new THREE.Group();
        for (let j=0; j<5; j++) {
          const puff = new THREE.Mesh(
            new THREE.SphereGeometry(20,8,8),
            new THREE.MeshPhongMaterial({ color:0xffffff, transparent:true, opacity:0.8 })
          );
          puff.position.set(Math.random()*40-20, Math.random()*10, Math.random()*40-20);
          cloud.add(puff);
        }
        cloud.position.set(Math.random()*1600-800, 200+Math.random()*100, Math.random()*1600-800);
        scene.add(cloud);
      }

      // Diamonds & Monsters
      const DIAMOND_COUNT = 100;
      spawnDiamonds(DIAMOND_COUNT);
      totalDiamonds = DIAMOND_COUNT;                // always use the requested number
      totalDiamondsEl.textContent   = DIAMOND_COUNT;
      winTotalDiamondsEl.textContent = DIAMOND_COUNT;

      totalDiamondsEl.textContent = totalDiamonds;
      winTotalDiamondsEl.textContent = totalDiamonds;
      spawnMonsters(10);

      // Renderer + events
      renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      window.addEventListener('resize', onResize);
      document.addEventListener('keydown', onKey);
      document.addEventListener('keyup', onKey);

      animate();
    }

    // Start / lock handlers
    function startGame() {
      resetGame();
      gameActive = true;
      startScreenEl.style.display = 'none';
      gameOverScreenEl.style.display = 'none';
      winScreenEl.style.display = 'none';
      overlayEl.style.display = 'block';
      timerEl.style.display = 'block';
      controlsGuideEl.style.display = 'block';

      gameTime = 0;
      clearInterval(gameTimer);
      gameTimer = setInterval(() => {
        if (gameActive && !won && !lost) {
          gameTime++;
          timeElapsedEl.textContent = gameTime;
        }
      }, 1000);

      controls.lock();
    }
    function onLock() { overlayEl.style.display='block'; timerEl.style.display='block'; controlsGuideEl.style.display='block'; }
    function onUnlock() {
      if (gameActive && !won && !lost) {
        gameActive=false;
        overlayEl.style.display='none';
        timerEl.style.display='none';
        controlsGuideEl.style.display='none';
        startScreenEl.style.display='flex';
        document.getElementById('startButton').textContent='RESUME GAME';
      }
    }

    // Win/Lose
    function gameOver() {
      gameActive=false; lost=true;
      controls.unlock();
      finalScoreEl.textContent = score;
      gameOverScreenEl.style.display='flex';
      clearInterval(gameTimer);
    }
    function winGame() {
      gameActive=false; won=true;
      controls.unlock();
      finalTimeEl.textContent = gameTime;
      winScreenEl.style.display='flex';
      clearInterval(gameTimer);
      fireworksRunning = true;
      setTimeout(() => fireworksRunning = false, 10000);
    }

    // Utility spawners
    function spawnObjects(type,count,radius,place) {
      let placed=0, attempts=0, max=count*100;
      while(placed<count && attempts<max) {
        attempts++;
        const x=Math.random()*1000-500, z=Math.random()*1000-500;
        const y=(type==='mountain'?200:12);
        const pos=new THREE.Vector3(x,y,z);
        if(!collidableBoxes.some(b=>b.intersectsSphere(new THREE.Sphere(pos,radius)))) {
          place(pos);
          placed++;
        }
      }
    }
    function spawnDiamonds(count) {
  // clear old
  diamonds.forEach(d => d && scene.remove(d));
  diamonds.length = 0;

  const geo = new THREE.OctahedronGeometry(5);
  const mat = new THREE.MeshPhongMaterial({
    color: 0x00ffff,
    emissive: 0x007777,
    shininess: 100
  });

  let placed = 0;
  // keep trying until we've placed 'count' diamonds
  while (placed < count) {
    const x = Math.random() * 1000 - 500;
    const z = Math.random() * 1000 - 500;
    const pos = new THREE.Vector3(x, 5, z);

    // test sphere so the diamond doesn't spawn inside trees/mountains
    const testSphere = new THREE.Sphere(pos, playerCollider.radius + 1);
    if (!collidableBoxes.some(b => b.intersectsSphere(testSphere))) {
      const d = new THREE.Mesh(geo, mat);
      d.position.copy(pos);
      d.userData = {
        rotationSpeed: Math.random() * 0.02 + 0.01,
        floatSpeed:    Math.random() * 0.01 + 0.005,
        floatHeight:   Math.random() * 0.5 + 0.5,
        startY:        pos.y
      };
      scene.add(d);
      diamonds.push(d);
      placed++;
    }
    // if you want a safety break, you could log after some huge number of attempts
  }
}

    function spawnMonsters(count) {
      monsters.forEach(m=>m&&scene.remove(m));
      monsters.length=0; monsterInitialPositions.length=0;
      const bodyGeo=new THREE.BoxGeometry(10,15,10),
            bodyMat=new THREE.MeshPhongMaterial({ color:0xff0000 }),
            eyeGeo=new THREE.SphereGeometry(1.5,8,8),
            eyeMat=new THREE.MeshPhongMaterial({ color:0xffffff }),
            pupilGeo=new THREE.SphereGeometry(0.7,8,8),
            pupilMat=new THREE.MeshPhongMaterial({ color:0x000000 });
      let placed=0, attempts=0;
      while(placed<count && attempts<count*50) {
        attempts++;
        const x=Math.random()*1000-500, z=Math.random()*1000-500;
        const pos=new THREE.Vector3(x,10,z);
        if(!collidableBoxes.some(b=>b.intersectsSphere(new THREE.Sphere(pos,monsterCollider.radius+1)))) {
          const mg=new THREE.Group();
          // Body
          const body=new THREE.Mesh(bodyGeo,bodyMat);
          mg.add(body);
          // Eyes (named)
          const leftEye=new THREE.Mesh(eyeGeo,eyeMat);
          leftEye.name='eye';
          leftEye.position.set(-2.5,5,5);
          mg.add(leftEye);
          const rightEye=new THREE.Mesh(eyeGeo,eyeMat);
          rightEye.name='eye';
          rightEye.position.set(2.5,5,5);
          mg.add(rightEye);
          // Pupils (named)
          const leftPupil=new THREE.Mesh(pupilGeo,pupilMat);
          leftPupil.name='pupil';
          leftPupil.position.set(-2.5,5,6);
          mg.add(leftPupil);
          const rightPupil=new THREE.Mesh(pupilGeo,pupilMat);
          rightPupil.name='pupil';
          rightPupil.position.set(2.5,5,6);
          mg.add(rightPupil);

          mg.position.copy(pos);
          scene.add(mg);
          monsters.push(mg);
          monsterInitialPositions.push(pos.clone());
          placed++;
        }
      }
    }

    // Event handlers
    function onResize() {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight);
    }
    function onKey(e) {
      if(e.code==='KeyF' && e.type==='keydown') fireworksRunning = !fireworksRunning;
      keys[e.code] = e.type==='keydown';
    }

    // Main loop
    function animate() {
      requestAnimationFrame(animate);
      frameCount++;

      // Diamonds float & rotate
      diamonds.forEach(d=>{
        if(!d) return;
        d.rotation.y += d.userData.rotationSpeed;
        d.rotation.x += d.userData.rotationSpeed*0.5;
        d.position.y = d.userData.startY +
          Math.sin(frameCount * d.userData.floatSpeed) * d.userData.floatHeight;
      });

      // Fireworks bursts
      const fireNow = fireworksRunning || (won && !lost);
      if(fireNow && frameCount % 30 === 0) {
        const burstPos = new THREE.Vector3(
          Math.random()*800-400,
          Math.random()*100+150,
          Math.random()*800-400
        );
        for(let i=0; i<40; i++) {
          const p = new FireworkParticle(burstPos);
          scene.add(p.mesh);
          fireworks.push(p);
        }
      }
      // Update particles
      for(let i=fireworks.length-1; i>=0; i--) {
        if(!fireworks[i].update()) {
          scene.remove(fireworks[i].mesh);
          fireworks.splice(i,1);
        }
      }

      if(gameActive && !won && !lost && controls.isLocked) {
        updatePlayer();
        updateDiamonds();
        updateMonsters();
      }

      renderer.render(scene,camera);
    }

    // Movement & collision
    function updatePlayer() {
      const pl = controls.getObject();
      pl.position.y = 10;
      const old = pl.position.clone();
      const dlt = 0.1;
      const dir = new THREE.Vector3(
        (keys['KeyD']?1:0)-(keys['KeyA']?1:0),
        0,
        (keys['KeyS']?1:0)-(keys['KeyW']?1:0)
      ).normalize();
      if(dir.length()) {
        const v = dir.multiplyScalar(400*dlt);
        pl.translateX(v.x*dlt);
        pl.translateZ(v.z*dlt);
        // Clamp bounds
        pl.position.x = Math.max(boundary.min,Math.min(boundary.max,pl.position.x));
        pl.position.z = Math.max(boundary.min,Math.min(boundary.max,pl.position.z));
        // Collision
        const sph = new THREE.Sphere(pl.position,playerCollider.radius);
        for(const b of collidableBoxes) {
          if(b.intersectsSphere(sph)) {
            pl.position.copy(old);
            break;
          }
        }
      }
    }

    // Pickup logic
    function updateDiamonds() {
      diamonds.forEach((d,i)=>{
        if(d && d.position.distanceTo(controls.getObject().position)<10) {
          scene.remove(d);
          diamonds[i] = null;
          score++;
          scoreEl.textContent = score;
          playPickupSound();
          if(score>=totalDiamonds) winGame();
        }
      });
    }
    function playPickupSound() {
      try {
        const ctx = new (window.AudioContext||window.webkitAudioContext)();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(880, ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(1760, ctx.currentTime+0.1);
        gain.gain.setValueAtTime(0.3, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime+0.2);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(); osc.stop(ctx.currentTime+0.2);
      } catch(e) { console.log("Audio not supported"); }
    }

    // Monster AI + eye tracking
    function updateMonsters() {
      const playerPos = controls.getObject().position;
      monsters.forEach(m => {
        // Rotate entire monster body on Y to face player
        const dir = new THREE.Vector3()
          .subVectors(playerPos, m.position)
          .setY(0)
          .normalize();
        if(dir.length()) {
          m.lookAt(m.position.clone().add(dir));
        }

        // Eye & pupil tracking
        m.traverse(obj => {
          if(obj.name==='eye'||obj.name==='pupil') {
            obj.lookAt(playerPos);
          }
        });

        // Step towards player with obstacle avoidance
        const v = new THREE.Vector3().subVectors(playerPos, m.position).normalize().multiplyScalar(0.5);
        ['x','z'].forEach(ax => {
          const tp = m.position.clone();
          tp[ax] += v[ax];
          if(!collidableBoxes.some(b=>b.intersectsSphere(new THREE.Sphere(tp,monsterCollider.radius)))) {
            m.position[ax] += v[ax];
          }
        });
        // Clamp
        m.position.x = Math.max(boundary.min,Math.min(boundary.max,m.position.x));
        m.position.z = Math.max(boundary.min,Math.min(boundary.max,m.position.z));
      });

      // Separate overlaps
      const sep=20;
      monsters.forEach((a,i)=>{
        monsters.forEach((b,j)=>{
          if(i>=j) return;
          const d=a.position.distanceTo(b.position);
          if(d<sep) {
            const push=a.position.clone().sub(b.position).normalize().multiplyScalar((sep-d)/2);
            a.position.add(push);
            b.position.sub(push);
          }
        });
      });

      // Check for catching player
      monsters.forEach(m=>{
        if(m.position.distanceTo(controls.getObject().position)<10 && !won && !lost) {
          gameOver();
        }
      });
    }

    // Reset for retry
    function resetGame() {
      score=0; won=false; lost=false;
      scoreEl.textContent=0;
      timeElapsedEl.textContent='0';
      controls.getObject().position.set(0,10,0);
      monsters.forEach((m,i)=>{
        if(i<monsterInitialPositions.length) {
          m.position.copy(monsterInitialPositions[i]);
        }
      });
      fireworks.forEach(f=>scene.remove(f.mesh));
      fireworks.length=0;
      frameCount=0;
      fireworksRunning=false;
    }
  </script>
</body>
</html>
